<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="xuzichao03@gmail.com"><title>自动布局 Masonry · LorisBlog</title><meta name="description" content="一、前言苹果出了新机型后需要进行适配，同时也给开发者提供了一套自动布局方案NSLayoutConstraint,不仅可以代码中实现约束，还可以在Xib上实现直接的约束。不过说实在的，因为它那冗长而又丑爆的语法，写一个约束要写那么多行，几个视图下来的代码结构比较难看，因此我是拒绝使用的，好在Mason"><meta name="keywords" content="开发者,程序猿,编程,用户体验,产品,IOS,UI,UE,视觉设计,FE,Golang"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">LorisBlog</a></h3><div class="description"><p>「About Life and Code」</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/archives">文章</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>自动布局 Masonry</a></h3></div><div class="post-content"><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>苹果出了新机型后需要进行适配，同时也给开发者提供了一套自动布局方案NSLayoutConstraint,不仅可以代码中实现约束，还可以在Xib上实现直接的约束。不过说实在的，因为它那冗长而又丑爆的语法，写一个约束要写那么多行，几个视图下来的代码结构比较难看，因此我是拒绝使用的，好在Masonry对它进行了友好封装，所以我才没有放弃对它更上一层的使用。</p>
<h3 id="二、Masonry"><a href="#二、Masonry" class="headerlink" title="二、Masonry"></a>二、Masonry</h3><h3 id="1、常规用法"><a href="#1、常规用法" class="headerlink" title="1、常规用法"></a>1、常规用法</h3><p>比如我们要写一个视图，他距离父视图的上边77pt,距离左边4pt,超出右边10pt,距离下边20pt,使用如下写法比系统自带的语法简洁很多，由于masonry的链式语法使你能够连续调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">UIView *view = [[UIView alloc]init];</div><div class="line">    </div><div class="line">[self.view addSubview:view];</div><div class="line">    </div><div class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.top.equalTo(self.view.mas_top).with.offset(77);</div><div class="line">        make.left.equalTo(self.view.mas_left).with.offset(4);</div><div class="line">        make.bottom.equalTo(self.view.mas_bottom).with.offset(-10);</div><div class="line">        make.right.equalTo(self.view.mas_right).with.offset(20);</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<h3 id="2、链式语法"><a href="#2、链式语法" class="headerlink" title="2、链式语法"></a>2、链式语法</h3><p>接下来我们分析下，是如何在OC的语法中实现链式调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</div><div class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</div><div class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</div><div class="line">    block(constraintMaker);</div><div class="line">    return [constraintMaker install];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先第一个方法可以看到，我们将block实现，但是在方法内部就直接执行了block,其实就相当于调用了一次，进来先关闭了视图的系统默认约束，然后创建了一个MASConstraintMaker并将它传回，这样我们才能在block内部进行约束赋值。用于方法属于view的一个category分类，所以此处就将MASConstraintMaker与View进行了绑定。我看接着看.top方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint *)top &#123;</div><div class="line">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];</div><div class="line">&#125;</div><div class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</div><div class="line">    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</div><div class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];</div><div class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</div><div class="line">    if ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</div><div class="line">        //replace with composite constraint</div><div class="line">        NSArray *children = @[constraint, newConstraint];</div><div class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</div><div class="line">        compositeConstraint.delegate = self;</div><div class="line">        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</div><div class="line">        return compositeConstraint;</div><div class="line">    &#125;</div><div class="line">    if (!constraint) &#123;</div><div class="line">        newConstraint.delegate = self;</div><div class="line">        [self.constraints addObject:newConstraint];</div><div class="line">    &#125;</div><div class="line">    return newConstraint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到在赋值到最后的返回值是依旧是一个MASViewConstraint对象，所以top和left、right、bottom是一样的使用。我们再来看equal_To和with以及offset</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint * (^)(id))equalTo &#123;</div><div class="line">    return ^id(id attribute) &#123;</div><div class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MASConstraint *)with &#123;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MASConstraint * (^)(CGFloat))offset &#123;</div><div class="line">    return ^id(CGFloat offset)&#123;</div><div class="line">        self.offset = offset;</div><div class="line">        return self;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到block的参数是需要赋的值，返回值则是可以进行下一轮赋值的MASConstraint，而这个block作为参数的时候,这个block是由外部来实现,内部调用的，当block作为返回值的时候,这个block是由内部来实现,外部调用的。通过将block作为参数和返回值，从而就实现了链式调用的语法。</p>
<p>3、使用注意</p>
<ul>
<li>约束视图对象只有在被addSubview之后，才能给视图添加约束</li>
<li>动画的使用是在更新约束之后调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[view.superview layoutIfNeeded];//强制绘制</div></pre></td></tr></table></figure>
<ul>
<li>masony由于是对系统api的封装，在视图数量较多和列表复用的使用会有性能问题</li>
<li>masonry和其他frame约束同时使用会有不可控问题发生</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-03-22</span><i class="fa fa-tag"></i><a href="/tags/开发/" title="开发" class="tag">开发 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://zichao.me/2015/03/22/自动布局 Masonry/,LorisBlog,自动布局 Masonry,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/07/22/设计模式MVC、MVP、MVVM/" title="工程结构MVC、MVVM、MVP" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/02/05/App的多语言国际化/" title="App的多语言国际化" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="youyan_thread" class="post"></div><script>(function() {

    var YYDiv = document.createElement('div');
    YYDiv.id = 'uyan_frame';
    document.getElementById('youyan_thread').appendChild(YYDiv);

    var YYScript = document.createElement('script');
    YYScript.type = 'text/javascript';
    YYScript.async = true;
    YYScript.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//v2.uyan.cc/code/uyan.js?uid=' + '2143349';
    YYScript.charset = 'UTF-8';
    document.getElementById('youyan_thread').appendChild(YYScript);

})();</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>