<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="xuzichao03@gmail.com"><title>iOS多线程 · Aloris</title><meta name="description" content="一、概述1、进程与线程
进程

进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。多个进程之间不存在相互影响。

线程

线程是程序执行时的最小单位，它是进"><meta name="keywords" content="开发者,程序猿,编程,用户体验,产品,IOS,UI,UE,视觉设计,FE,Golang"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Aloris</a></h3><div class="description"><p>「About Life and Code」</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/archives">文章</a></li><li><a href="/about">关于</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>iOS多线程</a></h3></div><div class="post-content"><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h5 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h5><ul>
<li>进程</li>
</ul>
<p>进程是资源分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。多个进程之间不存在相互影响。</p>
<ul>
<li>线程</li>
</ul>
<p>线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，所以相互通信更方便。每个线程有自己的堆栈和局部变量，但是没有自己的地址空间。一个线程低调则进程也死掉。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。</p>
<h5 id="2、iOS中的几种线程"><a href="#2、iOS中的几种线程" class="headerlink" title="2、iOS中的几种线程"></a>2、iOS中的几种线程</h5><p><img src="/assets/images/thread.png" alt=""></p>
<h3 id="二、NSThread"><a href="#二、NSThread" class="headerlink" title="二、NSThread"></a>二、NSThread</h3><p>NSThread是苹果对线程的封装，完全是面向对象的，你可以直接操作线程本身，创建和获得一个线程非常方便，但是线程的生命周期需要手动管理，在实现多线程的时候不太方便，所以我们使用的场景偏向于基础调用和读取较多一些。场景如下：</p>
<h5 id="1、读取线程信息"><a href="#1、读取线程信息" class="headerlink" title="1、读取线程信息"></a>1、读取线程信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//主线程</div><div class="line">[NSThread mainThread]；</div><div class="line">[NSThread isMainThread];</div><div class="line"></div><div class="line">//当前线程</div><div class="line">[NSThread currentThread];</div><div class="line"></div><div class="line">//是否多线程</div><div class="line">[NSThread isMultiThreaded];</div><div class="line"></div><div class="line">//实例线程状态</div><div class="line">thread.isExecuting;</div><div class="line">thread.isCancelled;</div><div class="line">thread.isFinished;</div></pre></td></tr></table></figure>
<h5 id="2、阻塞一个线程"><a href="#2、阻塞一个线程" class="headerlink" title="2、阻塞一个线程"></a>2、阻塞一个线程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//休眠到指定时间</div><div class="line">[NSThread sleepUntilDate:[NSDate date]];</div><div class="line">//休眠指定时长</div><div class="line">[NSThread sleepForTimeInterval:4.5];</div></pre></td></tr></table></figure>
<h5 id="3、退出和取消线程"><a href="#3、退出和取消线程" class="headerlink" title="3、退出和取消线程"></a>3、退出和取消线程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">//实例</div><div class="line">thread.cancel</div></pre></td></tr></table></figure>
<h5 id="4、在某个线程上执行方法，也属于线程通信"><a href="#4、在某个线程上执行方法，也属于线程通信" class="headerlink" title="4、在某个线程上执行方法，也属于线程通信"></a>4、在某个线程上执行方法，也属于线程通信</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//主线程执行</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class="line"></div><div class="line">//后台线程执行</div><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg；</div><div class="line"></div><div class="line">//某一个子线程执行</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait；</div></pre></td></tr></table></figure>
<h3 id="三、GCD"><a href="#三、GCD" class="headerlink" title="三、GCD"></a>三、GCD</h3><p>GCD是苹果提出的多核运行方案伟大的中央调度系统，基于C语言用来替代NSThread。自动管理线程的生命周期，包括创建销毁和执行，以Block的形式接口，功能强大且方便灵活，现实开发中基本涵盖全部场景,包含几个基本概念。</p>
<p>block任务：你的操作，也即是Block中那段代码。</p>
<p>queue队列：用于存放任务并等待执行的栈容器。</p>
<p>sync同步：只在当前线程中执行。</p>
<p>async异步：可以开启新的线程。</p>
<p>concurrent并发：多个任务同时执行。</p>
<p>serial串行：一个任务执行完毕再执行下一个。</p>
<h5 id="1、创建队列"><a href="#1、创建队列" class="headerlink" title="1、创建队列"></a>1、创建队列</h5><ul>
<li>主队列是特殊的串行队列，UI相关的操作只能放主队列</li>
<li>自己创建的队列可以是串行的也可以是并行的队列</li>
<li>全局队列是系统提供的一个全局的并发队列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//主队列UI</div><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div><div class="line"></div><div class="line">//自己创建队列</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">//全局并发队列</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div></pre></td></tr></table></figure>
<h5 id="2、创建任务"><a href="#2、创建任务" class="headerlink" title="2、创建任务"></a>2、创建任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//异步任务，新起一个线程，等这个队列什么时候安排Block</div><div class="line">dispatch_async(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</div><div class="line"></div><div class="line">//同步任务，等这个队列什么时候安排Block</div><div class="line">dispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);</div></pre></td></tr></table></figure>
<ul>
<li>两个阻塞案例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//只会打印1，因为sync阻塞了主线程</div><div class="line">NSLog(&quot;1 - %@&quot;, NSThread.currentThread())</div><div class="line">dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in </div><div class="line">        NSLog(&quot;2 - %@&quot;, NSThread.currentThread())</div><div class="line">&#125;)</div><div class="line">NSLog(&quot;3 - %@&quot;, NSThread.currentThread())</div><div class="line"></div><div class="line"></div><div class="line">//只会打印1，因为sync阻塞了自己创建的线程queue</div><div class="line">dispatch_async(queue, &#123; () -&gt; Void in</div><div class="line">    NSLog(&quot;1 - %@&quot;, NSThread.currentThread())</div><div class="line">    dispatch_sync(queue, &#123; () -&gt; Void in</div><div class="line">         NSLog(&quot;2 - %@&quot;, NSThread.currentThread())</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line">NSLog(&quot;3 - %@&quot;, NSThread.currentThread())</div></pre></td></tr></table></figure>
<h5 id="3、其他用法"><a href="#3、其他用法" class="headerlink" title="3、其他用法"></a>3、其他用法</h5><ul>
<li>延时执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time_t when,dispatch_queue_t queue,dispatch_block_t block);</div></pre></td></tr></table></figure>
<ul>
<li>一次执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static dispatch_once_t onceToken;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    // 只执行1次的代码(这里面默认是线程安全的)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>组合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//其实是和队列进行绑定，最后都完成之后会发出一个notify</div><div class="line">dispatch_queue_t disqueue =  dispatch_queue_create(&quot;com.shidaiyinuo.NetWorkStudy&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t disgroup = dispatch_group_create();</div><div class="line">dispatch_group_async(disgroup, disqueue, ^&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;任务一完成&quot;);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">dispatch_group_async(disgroup, disqueue, ^&#123;</div><div class="line">    </div><div class="line">    sleep(8);</div><div class="line">    NSLog(@&quot;任务二完成&quot;);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">dispatch_group_notify(disgroup, disqueue, ^&#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;dispatch_group_notify 执行&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ul>
<li>信号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t  signal = dispatch_semaphore_create(1);</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        sleep(1);</div><div class="line">        x = dispatch_semaphore_signal(signal);</div><div class="line">    &#125;);</div><div class="line">x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);</div></pre></td></tr></table></figure>
<h3 id="四、NSOperation"><a href="#四、NSOperation" class="headerlink" title="四、NSOperation"></a>四、NSOperation</h3><p>NSOperation是苹果对GCD的封装，也是面向对象的，实现了一些GCD不好实现的功能。NSOperation是基类不能添加任务，需要再子类NSInvocationOperation和NSBlockOperation中实现，可以配合NSOperationQueue使用，分别对应GCD里面的任务和队列。</p>
<h5 id="1、执行任务"><a href="#1、执行任务" class="headerlink" title="1、执行任务"></a>1、执行任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//start方法，直接在当前线程执行</div><div class="line"></div><div class="line">//NSInvocationOperation</div><div class="line">NSOperation *op = [[NSInvocationOperation alloc]initWithTarget:self </div><div class="line">selector:@selector(downloadImage:) object:@&quot;Invocation&quot;];</div><div class="line">[op start];</div><div class="line"></div><div class="line">//NSBlockOperation同理</div></pre></td></tr></table></figure>
<h5 id="2、进入队列"><a href="#2、进入队列" class="headerlink" title="2、进入队列"></a>2、进入队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *q = [[NSOperationQueue alloc]init];</div><div class="line">[q addOperationWithBlock:^&#123;</div><div class="line">  NSLog(@&quot;%@------%d&quot;,[NSThread currentThread],i);</div><div class="line">&#125;];</div><div class="line">[q start];</div></pre></td></tr></table></figure>
<h5 id="3、其他用法-1"><a href="#3、其他用法-1" class="headerlink" title="3、其他用法"></a>3、其他用法</h5><ul>
<li>创建依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[operation2 addDependency:operation1]; </div><div class="line">[operation3 addDependency:operation2]; </div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperations:@[operation3, operation2, operation1] waitUntilFinished:NO];</div></pre></td></tr></table></figure>
<ul>
<li>属性设置与操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//最大线程数量</div><div class="line">NSInteger maxConcurrentOperationCount</div><div class="line"></div><div class="line">//获取队列的任务数</div><div class="line">NSUInteger operationCount; </div><div class="line"></div><div class="line">//取消队列中所有的任务</div><div class="line">- (void)cancelAllOperations; </div><div class="line"></div><div class="line">//阻塞当前线程直到此队列中的所有任务执行完毕</div><div class="line">- (void)waitUntilAllOperationsAreFinished; </div><div class="line"></div><div class="line">// 暂停与继续</div><div class="line">[queue setSuspended:YES]; </div><div class="line">[queue setSuspended:NO];</div></pre></td></tr></table></figure>
<h3 id="五、pthread"><a href="#五、pthread" class="headerlink" title="五、pthread"></a>五、pthread</h3><p>pthread，是线程的POSIX标准。该标准定义了创建和操纵线程的一整套API。在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用Pthreads作为操作系统的线程。移植性很强，当然在 iOS 中也是可以的。使用C语言函数，所有线程的管理都需要手动处理，简单看下使用方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//在线程上执行一个funcName函数方法</div><div class="line">pthread_t thread;</div><div class="line">//创建一个线程并自动执行</div><div class="line">pthread_create(&amp;thread, NULL, funcName, NULL);</div></pre></td></tr></table></figure>
<h3 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h3><ul>
<li>NSThread使用简单，自己管理生命周期。</li>
<li>GCD有任务和队列，做到了NSOperation不能的：一次性执行、延迟执行、调度组</li>
<li>NSOperation有任务和队列，做到了GCD不能的：最大并发数、暂停和继续、取消、依赖关系</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-06-27</span><i class="fa fa-tag"></i><a href="/tags/开发/" title="开发" class="tag">开发 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://zichao.me/2015/06/27/iOS多线程/,Aloris,iOS多线程,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2015/09/10/Native与Web的通信桥/" title="Native与Web的通信桥" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/04/10/锁机制/" title="锁机制" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="youyan_thread" class="post"></div><script>(function() {

    var YYDiv = document.createElement('div');
    YYDiv.id = 'uyan_frame';
    document.getElementById('youyan_thread').appendChild(YYDiv);

    var YYScript = document.createElement('script');
    YYScript.type = 'text/javascript';
    YYScript.async = true;
    YYScript.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//v2.uyan.cc/code/uyan.js?uid=' + '2143349';
    YYScript.charset = 'UTF-8';
    document.getElementById('youyan_thread').appendChild(YYScript);

})();</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>