<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Deadlock博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Deadlock博客">
<meta property="og:url" content="http://xuzichao.com/page/2/index.html">
<meta property="og:site_name" content="Deadlock博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Deadlock博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Deadlock博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/photo.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?0b8e8ee87e4708173f00d9048c309301";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/photo.png" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Deadlock</a></h1>
		</hgroup>

		
		<p class="header-subtitle">华中科技大学毕业，今日头条在职</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/xuzichao" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2356167600/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo">weibo</a>
					        
								<a class="facebook" target="_blank" href="https://www.facebook.com/zichao.xu.5" title="facebook">facebook</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/时光相册/" style="font-size: 10px;">时光相册</a> <a href="/tags/程序开发/" style="font-size: 20px;">程序开发</a> <a href="/tags/随笔小结/" style="font-size: 15px;">随笔小结</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Deadlock</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/assets/photo.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Deadlock</h1>
			</hgroup>
			
			<p class="header-subtitle">华中科技大学毕业，今日头条在职</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/xuzichao" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2356167600/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="weibo">weibo</a>
			        
						<a class="facebook" target="_blank" href="https://www.facebook.com/zichao.xu.5" title="facebook">facebook</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-我短暂的创业经历" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/12/21/我短暂的创业经历/" class="article-date">
  	<time datetime="2015-12-21T07:01:22.000Z" itemprop="datePublished">Dec 21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/21/我短暂的创业经历/">我短暂的创业经历</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>互联网圈内，去哪儿旅行对外展示着的形象是加班多，偶尔还传出员工猝死的消息，然而任何一家公司也并不是每个部门都加班，并不是每个部门都有那么多亟不可待的业务需要去追赶，反而，在这里，我每天的工作自在舒适，按需完成，加班是很少的，如果你不想去外面的世界翻滚，这里就是你长久生养之地。那个时候我就是一枚螺丝开发，由于业务需求没有那么多，所以每日我只需要自己安排完成一定的工作量即可，有时候需求周期因为各端同事的配合时间也会被拉长，所以其实我大部分时间就是在自己浏览学习，没有实际的业务上手实践。而与此同时，互联网界正在迅猛发展，每天看着的都是各自CEO的诞生，各自融资拿钱拿到手软，这不禁也影响着我。<br>所以，尽管如此，尽管这里是整个互联网最安逸的体现，到了今年的7月份时候，我还是决心离开这温暖的被窝，离开我每日安享的梦境，全心投身创业。我却开始有些难过，因为那是我第一份工作，和去哪儿也是很有缘分的说，跟大家告别的时候特别伤心。一阵心塞之后，我的雄心开始燃烧，总是想着要闯出一片天地，对未来充满希望和无限遐想，想到我会享受着创业成就感与创业艰辛的交织幸福感，内心便激动起来。</p>
<p>加入的创业公司属于互联网汽车行业，与一般不同的是，做的是汽车B2B模式平台。加入前，我和公司的领头人聊得很好，不仅是因为旧相识，谈得更多的是对整个业务未来的展望，他侃侃而谈，把整个行业给我分析了一遍，我似乎找不到哪里一点他说的不对，只有当我问到如果事情没有按照你所推演的发展，这中间出现环节出错误的时候，他才有些避重就轻。当时我的理解，在此投资环境如此之好得情况下，任何一家创业公司的带头人应该都是这幅样子，要利用互联网优势把这个市场搅拌，要让传统行业为我们所用的架势,遇见的问题自然也会有办法。汽车市场如此之大，随便能咬到一口就是丰厚的回报，而早期的成员就自然不言而喻。同时已经拿到投资，数额可观，在此基础上开始讲解了如何去且足以推动整个业务的初期发展，到这里我确实接触到了不少我之前没能接触到的各种环境，且对他的信任，就基本已经奠定我后来加入的格局了。</p>
<p>加入团队后，秉承着我创业的心态一直很有干劲，除了自己分管的一些业务，其他大小事务也有一些参与感，看着产品的不断迭代和上线，我看到了自己努力的结果，心里满足，同时也收获了很多朋友，直到上周五离开，整整5个月了。</p>
<p>那么问题来了，我为何还是选择离开？</p>
<p>事情似乎看着一切进展顺利，产品上线，人员分工合理，但其中的原因并不缺乏，一切可以说只是看起来顺利，可以说常见的创业问题几乎在这个公司都体现出来了，尤其到后来资本市场的寒冬到来，互联网经济受影响，4个月之后出现融资困难，在这时候公司问题更加的突出了。</p>
<p>首先说说产品，因为我是过去做开发的。产品的存在是为了服务公司的业务，开发人员和产品人员每日工作干进度是为了早日将这些服务呈现出来，按照我们的业务形态，产品的主要使用对象是汽车经销商，包括二级和4S在内。当时，产品和技术说现在版本上线了，大家可以推广使用了，却没有啥回应，包括几个带头人，他们对产品的使用好像并不在意，原本该我们的销售人员向对应的经销商开始推广安装使用，却没有一个销售人员相应行动。在团队产品的推进过程中，他们不会关心现在有多少人在使用了，不会关心技术团队的人加班后又做到什么程度了，这只是产品，为什么我单独说产品，因为三个合伙人是有一个专门管产品的，我看到的是他时常悠闲的在购物。</p>
<p>再说说领导的意识和管理，到公司内部的管理也是混乱，涉及到大家过了实习期转正问题的时候，负责人基本不在意，一问就说有事之后再说，一拖就是近10天，我自己倒是干得还可以，也相信负责人，但其中不乏一些刚毕业的学生同事，他们感受到的更多是不幸福，严重降低大家创业积极性，不过这些算是也创业的小问题，在这个创业环境下，我们都可以接受，都可以认为没什么，因为大家在业务兴起的时候，必须各自忙着自己这一块，可能管不了很多。</p>
<p>所以我们来说说，销售业务，这个公司最关键的地方，产品再好，没有业绩没有数据，一切为空。互联网汽车行业，单纯靠互联网的产品哪能，这也许成为前面大家忽视的原因，更多的精力放在了销售业务上，所以从这个角度看过去前面的好像也可以理解。销售团队向各级经销商，通过公司平台进行车源交易，从最初开始，产品技术和销售一起去往同一个地方推广，做销售的事情，活动覆盖了一个省，到现在建立几个省的销售区，规模也是有了。但是到现在，销售的量，汽车的成交量，一直没有突破，一直处于很低的指数，而这同时，最初的投资已经消耗了不少了，直到我离开的时候，销售的业务还是没有起，销售队伍已经快瓦解。公司各个方面的不足导致公司现在人心涣散，那些留下同事的理由唯一就是还有那么些钱可以消耗，可以再观望一阵。后来，到带头人发现有些带不动大家的时候，开始找大家吃饭讲问题，每次一讲都是几个小时。可在又一次的会议上，我们大家一起探讨，说到我们这次离开北京去浙江做到什么程度其实我也不知道，做多久其实我也不知道，最后，他自己也说了一句，要是我们这个没做起来，就换个方向做。我问，什么是换个方向，他说，就是不做这业务了找其他事情做。听到这里的时候，我开始确定我之前的怀疑，看来并不是我自己创业心智不够成熟，是确实这件事情本身存在了我们没能解决的不足。随后，销售团队首先开始离职，技术团队先后离职了，我也就是其中一个。</p>
<p>今天是周一，写了些文字，为了记录一下我这次经历吧，我对整个公司没有什么负面情绪，相反，从领头人到和我工作的同事，大家都对我很照顾，平常也是一起其乐融融的生活，自己也成长进步。倒是这次的经历之后，让我开始反思自己究竟想要做什么，自己适合做什么，写这篇文章不仅是总结，也是分享给其他有兴趣的人看看吧。我给自己mark,让自己以后的路会做到走的更好。</p>
<p>我在咖啡屋里，周围好些人，或看书，或攀谈，抿一口，待会继续投简历。</p>
<blockquote>
<h3 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h3></blockquote>
<p>离我当时离开过了一年半了，我走的时候有一位坚持留下的开发同事走了，去了小米，随后也走了一名产品同事，去了高德地图，那位合伙的产品负责人也走了，去了一家互联网家具公司担任负责人。剩下的其他同事都还在，他们也招了新同事，也改了发展路线，目前在慈溪开了三家汽车品牌服务维修店，大概是做汽车销售品牌的路线。比之前有很多进展，但是要走的路还很长，真的很长，祝愿他们能更快的取得更好的成果。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔小结/">随笔小结</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Native与Web的通信桥" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/10/Native与Web的通信桥/" class="article-date">
  	<time datetime="2015-09-10T10:22:41.000Z" itemprop="datePublished">Sep 10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/10/Native与Web的通信桥/">Native与Web的通信桥</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Webview方式："><a href="#一、Webview方式：" class="headerlink" title="一、Webview方式："></a>一、Webview方式：</h2><h3 id="1、JS调用Native"><a href="#1、JS调用Native" class="headerlink" title="1、JS调用Native"></a>1、JS调用Native</h3><h3 id="1-1-webview加载流程"><a href="#1-1-webview加载流程" class="headerlink" title="1.1 webview加载流程"></a>1.1 webview加载流程</h3><ul>
<li>发起一个网页请求</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>loadRequest:<span class="params">(NSURLRequest *)</span>request</span><br></pre></td></tr></table></figure>
<ul>
<li>代理回调判断是否加载当前请求</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>webView:<span class="params">(UIWebView *)</span>webView </span><br><span class="line">shouldStartLoadWithRequest:<span class="params">(NSURLRequest *)</span>request </span><br><span class="line">navigationType:<span class="params">(UIWebViewNavigationType)</span>navigationType;</span><br></pre></td></tr></table></figure>
<ul>
<li>开始请求的时机</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>webViewDidStartLoad:<span class="params">(UIWebView *)</span>webView;</span><br></pre></td></tr></table></figure>
<ul>
<li>成功完成加载请求</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>webViewDidFinishLoad:<span class="params">(UIWebView *)</span>webView;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求失败</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>webView:<span class="params">(UIWebView *)</span>webView didFailLoadWithError:<span class="params">(NSError *)</span>error;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-URL拦截"><a href="#1-2-URL拦截" class="headerlink" title="1.2 URL拦截"></a>1.2 URL拦截</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">webView</span><span class="selector-pseudo">:(UIWebView</span> *)<span class="selector-tag">webView</span> </span><br><span class="line"><span class="selector-tag">shouldStartLoadWithRequest</span><span class="selector-pseudo">:(NSURLRequest</span> *)<span class="selector-tag">request</span> </span><br><span class="line"><span class="selector-tag">navigationType</span><span class="selector-pseudo">:(UIWebViewNavigationType)navigationType</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//JS发起的nativePage调用</span></span><br><span class="line">	<span class="selector-tag">if</span> ([request.URL.scheme <span class="attribute">isEqualToString</span>:@<span class="string">"SchemeName"</span>]) &#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//这里是应用内部的schema跳转分发逻辑</span></span><br><span class="line">       <span class="selector-attr">[Router openNewPage:url]</span>;</span><br><span class="line">       <span class="comment">//返回NO，不打开新网页</span></span><br><span class="line">       return NO; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//JS发起的事件Bridge调用</span></span><br><span class="line">   <span class="selector-tag">if</span>([request.URL.scheme <span class="attribute">isEqualToString</span>:@<span class="string">"JSBridgeName"</span>])</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//这里是应用内部的JS事件处理逻辑分发</span></span><br><span class="line">       <span class="selector-attr">[JSBridgeManager dealWithAction:url webView:webView]</span>;</span><br><span class="line">       <span class="comment">//返回NO，不打开新网页</span></span><br><span class="line">       return NO; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return YES;<span class="comment">//默认打开请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-请求分发"><a href="#1-3-请求分发" class="headerlink" title="1.3 请求分发"></a>1.3 请求分发</h3><p>注意上面的Router，其实也可以用JSBridgeManager事件进行分发，跟进传入的参数来判定即可，这里单独提炼出去，可以更好使得业务功能拆分复用。</p>
<p>拦截下JS的请求后，我们开始构建自己的JSBridgeManager。</p>
<ul>
<li>定义我们执行JS事件的webview为JSWebView，包含对应执行JS的方法</li>
<li>和前端约定一个固定接口，当前webview执行JS事件的时候，暴露一个方法给Native，Native调用来获取执行事件的时候所需要的额外信息，此处定义为”JSBridgeManager._fetchInfo()”</li>
<li>获取完返回的信息后执行解析为一个数组，数组里面每一个对象都是一个可执行的命令体，通过转化我们定义命令体对象JSCommand</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息类型</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *messageType;</span><br><span class="line"><span class="comment">//事件ID</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *eventID;</span><br><span class="line"><span class="comment">//回调ID</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *callbackID;</span><br><span class="line"><span class="comment">//消息参数</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *params;</span><br><span class="line"><span class="comment">//前端传过来的方法名</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *fullName;</span><br><span class="line"><span class="comment">//方法名</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *methodName;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义一个JSForwardManager对象,专门用于转发命令，根据native的本地协定好的方法名和格式，动态消息转发。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)<span class="string">dealWithAction:</span>(NSURLRequest *)request <span class="string">withWebView:</span>(JSWebView *)webView &#123;</span><br><span class="line">    NSURL *url = request.URL;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![webView <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">ttr_evaluateJavaScript:</span><span class="string">completionHandler:</span>)]) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    [webView <span class="string">evaluateJavaScript:</span>@<span class="string">";window.JSBridgeManager &amp;&amp; JSBridgeManager._fetchInfo();"</span> <span class="string">completionHandler:</span>^(id result, NSError *error) &#123;</span><br><span class="line">        NSArray *messagesData = [result JSONValue];</span><br><span class="line">        <span class="keyword">for</span>(NSDictionary *messageData <span class="keyword">in</span> messagesData) &#123;</span><br><span class="line">            JSCommand *command = [[JSCommand alloc] <span class="string">initWithDictonary:</span>messageData];</span><br><span class="line">            [[JSForwardManager sharedInstance] <span class="string">forwardJSBWithCommand:</span>command <span class="string">engine:</span>webView <span class="string">completion:</span>^(TTRJSBMsg msg, NSDictionary *response) &#123;</span><br><span class="line">                [self <span class="string">invokeJSBCallbackWithCommand:</span>command <span class="string">msg:</span>msg <span class="string">data:</span>response <span class="string">webView:</span>webView];</span><br><span class="line">            &#125;];;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>处理传入进来的命令，根据JSCommand查找本地规则对应的JSPlugin，JSPlugin则是各个JS事件对应调用的实际Native对象，该对象由业务方自己实习，继承自JSPlugin，最后通过NSInvocation直接调用对应的方法。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)<span class="string">forwardDynamicPluginWithCommand:</span>(JSCommand *)command <span class="string">engine:</span>(id&lt;JSEngine&gt;)engine <span class="string">completion:</span>(JSResponse)completion &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *selectorStr = [command.methodName <span class="string">stringByAppendingString:</span>@<span class="string">"WithParam:callback:webView:controller:"</span>];</span><br><span class="line">    SEL selector = NSSelectorFromString(selectorStr);</span><br><span class="line">    </span><br><span class="line">    JSPlugin *plugin = [self <span class="string">_generatePluginWithCommand:</span>command <span class="string">engine:</span>engine];</span><br><span class="line">    <span class="keyword">if</span> (![plugin <span class="string">respondsToSelector:</span>selector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMethodSignature *signature = [plugin <span class="string">methodSignatureForSelector:</span>selector];</span><br><span class="line">    NSInvocation *invocation = [NSInvocation <span class="string">invocationWithMethodSignature:</span>signature];</span><br><span class="line">    invocation.target = plugin;</span><br><span class="line">    invocation.selector = selector;</span><br><span class="line">    </span><br><span class="line">    NSDictionary *params = command.params;</span><br><span class="line">    [invocation <span class="string">setArgument:</span>&amp;params <span class="string">atIndex:</span><span class="number">2</span>];</span><br><span class="line">    [invocation <span class="string">setArgument:</span>&amp;completion <span class="string">atIndex:</span><span class="number">3</span>];</span><br><span class="line">    [invocation <span class="string">setArgument:</span>&amp;engine <span class="string">atIndex:</span><span class="number">4</span>];</span><br><span class="line">    UIViewController *source = engine.ttr_sourceController;</span><br><span class="line">    [invocation <span class="string">setArgument:</span>&amp;source <span class="string">atIndex:</span><span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意此处的completion回调，会返回去执行原来传进来的block，这里的JSResponse类都由本地实现和定义，最后在原webview里面执行脚本JS方法</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self <span class="string">invokeJSBCallbackWithCommand:</span>command <span class="string">msg:</span>msg <span class="string">data:</span>response <span class="string">webView:</span>webView];</span><br><span class="line"></span><br><span class="line">[self <span class="string">evaluateJavaScriptFromString:</span>javaScriptString <span class="string">completionBlock:</span>completionHandler];</span><br></pre></td></tr></table></figure>
<h3 id="2、Native调用JS"><a href="#2、Native调用JS" class="headerlink" title="2、Native调用JS"></a>2、Native调用JS</h3><p>与上述最后一步回调一样，实际就是webview的一个执行JS的方法。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="name">nullable</span> NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="二-基于JavaScriptCore"><a href="#二-基于JavaScriptCore" class="headerlink" title="二. 基于JavaScriptCore"></a>二. 基于JavaScriptCore</h2><h3 id="1、JS调用Native-1"><a href="#1、JS调用Native-1" class="headerlink" title="1、JS调用Native"></a>1、JS调用Native</h3><h3 id="1-1-获取当前JS环境"><a href="#1-1-获取当前JS环境" class="headerlink" title="1.1 获取当前JS环境"></a>1.1 获取当前JS环境</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="keyword">JSContext </span>= [self.<span class="keyword">baseWebView </span>valueForKeyPath:@<span class="string">"documentView.webView.mainFrame.javaScriptContext"</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-在Native定义JS环境对象"><a href="#1-2-在Native定义JS环境对象" class="headerlink" title="1.2 在Native定义JS环境对象"></a>1.2 在Native定义JS环境对象</h3><p>利用JSExport接口定义一套自己的业务接口协议，实现此协议的对象，可以放入JSContext环境中直接作为同名的JS方法调用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">BaseWebObjProctol</span> &lt;<span class="title">JSExport</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网页打开本地</span></span><br><span class="line">- (<span class="keyword">void</span>)openNativePage:(<span class="keyword">id</span>)param;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录</span></span><br><span class="line">- (<span class="keyword">void</span>)login;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用分享接口</span></span><br><span class="line">- (<span class="keyword">void</span>)shareToOthers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseWebObj</span> : <span class="title">NSObject</span>&lt;<span class="title">BaseWebObjProctol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) BaseWebVC *webVC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-注入JS对象"><a href="#1-3-注入JS对象" class="headerlink" title="1.3 注入JS对象"></a>1.3 注入JS对象</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    BaseWebObj *webObj = [[BaseWebObj alloc] init];</span><br><span class="line">    webObj.webVC = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.JSContext[<span class="string">@"nativeApp"</span>] = webObj;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-JS调用示例"><a href="#1-4-JS调用示例" class="headerlink" title="1.4 JS调用示例"></a>1.4 JS调用示例</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window<span class="selector-class">.nativeApp</span><span class="selector-class">.openUrlPage</span>(dictionary)</span><br></pre></td></tr></table></figure>
<h3 id="2、Native调用JS-1"><a href="#2、Native调用JS-1" class="headerlink" title="2、Native调用JS"></a>2、Native调用JS</h3><p>与上述最后一步回调一样，实际就是webview的一个执行JS的方法。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">JSContext </span>: NSObject</span><br><span class="line">- (JSValue *)<span class="attribute">evaluateScript</span>:(NSString *)script;</span><br></pre></td></tr></table></figure>
<h2 id="三、调试"><a href="#三、调试" class="headerlink" title="三、调试"></a>三、调试</h2><ul>
<li>手机: 设置-&gt;Safari-&gt;高级-&gt;打开web检查器</li>
<li>Safari: Safari-&gt;首选项-&gt;高级-&gt;打开 ‘在菜单中显示开发’ 选项</li>
<li>调试流程:Safari-&gt;开发-&gt;找到需要调试的设备-&gt;找到需要调试的页面</li>
<li>BTW: 可用于检测WebView实例的内存泄露</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-IOS 音频一览" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/15/IOS 音频一览/" class="article-date">
  	<time datetime="2015-03-15T04:34:11.000Z" itemprop="datePublished">Mar 15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/15/IOS 音频一览/">IOS 音频一览</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="IOS-音频一览"><a href="#IOS-音频一览" class="headerlink" title="IOS 音频一览"></a>IOS 音频一览</h4><blockquote>
<p>前言：<br>做嘉宾聊天室这个需求的时候接触了音频和视频上的开发，嘉宾可以发布视频和语音以及文字信息出来，观众则可以文字回复，这样主持人嘉宾和观众就形成一个良性的互动过程。在这里把相关整理一下，望给大家带来一些认识。</p>
</blockquote>
<h1 id="一、了解音频"><a href="#一、了解音频" class="headerlink" title="一、了解音频"></a>一、了解音频</h1><p>声音作为信息的一种媒介载体必不可少，在移动端体现为各类语音交流以及音乐等，开发中使用的音频文件通过声音采样、量化、编码几步从而成为人耳可听的声音，频率为20HZ到20KHZ，奈奎斯特的理论表明采样率高于最高频2倍时候，是可以将数字信号还原为原来的模拟信号的，所以通常我们在网上看到的音频文件的采样率为44.1KHZ。</p>
<p>采样后通过量化的脉冲编码调制，我们得到了PCM类型的数据，比如在使用AVAudioRecorder采样的时候可以看到采样类型kAudioFormatLinearPCM。但是这样拿到的数据是很大的，不便于使用和传输，通过对人类不敏感的声音区域进行过滤压缩，就有了MP3、AAC、OGG、WMA等数据格式类型，这些都是有损压缩。</p>
<p>码率代码了压缩质量，比如MP3常用码率有128kbit/s、160kbit/s、320kbit/s等等，越高代表着声音音质越好。MP3中的数据有ID3和音频数据组成，ID3用于存储歌名、演唱者、专辑、音轨等我们可以常见的信息。</p>
<h1 id="二、IOS对音频的操作"><a href="#二、IOS对音频的操作" class="headerlink" title="二、IOS对音频的操作"></a>二、IOS对音频的操作</h1><p>开发实际上是为了解决需求，需求对应的是使用场景，开发的方式很多，不同的使用场景可以使用的方法不同。IOS开发提供了以下几种常用方式供我们解决对应的音频需求。</p>
<ul>
<li>System Sound Services </li>
<li>AVFoundation 框架</li>
<li>Media Player 框架</li>
</ul>
<h2 id="2-1-System-Sound-Services"><a href="#2-1-System-Sound-Services" class="headerlink" title="2.1  System Sound Services"></a>2.1  System Sound Services</h2><h4 id="2-1-1-场景特点"><a href="#2-1-1-场景特点" class="headerlink" title="2.1.1 场景特点"></a>2.1.1 场景特点</h4><p>最底层也是简单的声音播放服务，此方法是适合播放提示警告类型的短小的声音</p>
<h4 id="2-1-2-存在限制"><a href="#2-1-2-存在限制" class="headerlink" title="2.1.2 存在限制"></a>2.1.2 存在限制</h4><ul>
<li>声音长度要小于 30 秒</li>
<li>In linear PCM 或者 IMA4 (IMA/ADPCM) 格式的</li>
<li>打包成 .caf, .aif, 或者 .wav 的文件</li>
<li>不能控制播放的进度</li>
<li>调用方法后立即播放声音</li>
<li>没有循环播放和立体声控制：</li>
</ul>
<h4 id="2-1-3-使用方式"><a href="#2-1-3-使用方式" class="headerlink" title="2.1.3 使用方式"></a>2.1.3 使用方式</h4><p>调用 AudioServicesCreateSystemSoundID(CFURLRef inFileURL,SystemSoundID *outSystemSoundID) 该函数的第一个参数代表音频文件的URL（可通过NSURL转换成CFURLRef），第二个参数代表注册音频文件的SystemSoundID。</p>
<p>调用AudioServicesAddSystemSoundCompletion()函数为制定SystemSoundID注册Callback函数。有了 CallBack 函数我们可以解决不少问题，比如可以克服 System Sound Services 本身不支持循环播放的问题。</p>
<p>调用AudioServicePlaySystemSound函数或者AudioServicePlayAlertSound（调用系统振动功能）。</p>
<pre><code>- (void)viewDidLoad
{
[super viewDidLoad];

// 1. 定义要播放的音频文件的URL
NSURL *voiceURL = [[NSBundle mainBundle]URLForResource:@&quot;CleanDidFinish&quot; withExtension:@&quot;aiff&quot;];

// 2. 注册音频文件（第一个参数是音频文件的URL 第二个参数是音频文件的SystemSoundID）
AudioServicesCreateSystemSoundID((__bridge CFURLRef)(voiceURL),&amp;ditaVoice);

// 3. 为crash播放完成绑定回调函数AudioServicesAddSystemSoundCompletion(ditaVoice,NULL,NULL,(void*)completionCallback,NULL);

// 4. 播放 ditaVoice 注册的音频 并控制手机震动
AudioServicesPlayAlertSound(ditaVoice);

//    AudioServicesPlaySystemSound(ditaVoice);
//    AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); // 控制手机振动

}
</code></pre><h2 id="2-2-AVFoundation-框架"><a href="#2-2-AVFoundation-框架" class="headerlink" title="2.2  AVFoundation 框架"></a>2.2  AVFoundation 框架</h2><h4 id="2-2-1-场景特点"><a href="#2-2-1-场景特点" class="headerlink" title="2.2.1 场景特点"></a>2.2.1 场景特点</h4><p>如果播放较大的音频或者要对音频有精确的控制，则System Sound Service可能就很难满足实际需求了，通常这种情况会选择使用AVFoundation，它可以满足我们通常意义上的绝大部分的场景需求，包括音乐的交互、声音的制作等等，根据自己的业务需求实现自定义的定制化。如果你只是想实现音频的播放或者录制，没有其他需求，AVFoundation会很好的满足你，它的接口使用简单、不用关心其中的细节。</p>
<h4 id="2-2-2-关键点和API浏览"><a href="#2-2-2-关键点和API浏览" class="headerlink" title="2.2.2 关键点和API浏览"></a>2.2.2 关键点和API浏览</h4><blockquote>
<p>Background Modes</p>
</blockquote>
<p>打开后台模式的音乐播放，或者在info.plist文件中添加Required Background Modes键，其值是App plays audio or streams audio/video using AirPlay</p>
<blockquote>
<p>AVAudioSession</p>
</blockquote>
<p>用于 iOS 系统中协调应用程序之间的音频播放的 API 的。例如，当有电话打进来时，音频的播放就会被暂停；在用户启动电影时，音乐的播放就会停止。我们需要使用这些 API 来确保一个应用程序能够正确响应并处理这类事件。</p>
<blockquote>
<p>AVAudioPlayer</p>
</blockquote>
<p>这个高层级的 API 为你提供一个简单的接口，用来播放本地或者内存中的音频。这是一个无界面的音频播放器 (也就是说没有提供 UI 元素)，使用起来也很直接简单。它不适用于网络音频流或者低延迟的实时音频播放。如果这些问题都不需要担心，那么 AVAudioPlayer 可能就是正确的选择。音频播放器的 API 也为我们带来了一些额外的功能，比如循环播放、获取音频的音量强度等等。</p>
<blockquote>
<p>AVAudioRecorder</p>
</blockquote>
<p>作为与 AVAudioPlayer 相对应的 API，AVAudioRecorder 是将音频录制为文件的最简单的方法。除了用一个音量计接受音量的峰值和平均值以外，这个 API 简单粗暴，但要是你的使用场景很简单的话，这可能恰恰就是你想要的方法。</p>
<blockquote>
<p>AVPlayer</p>
</blockquote>
<p>AVPlayer 与上面提到的 API 相比，提供了更多的灵活性和可控性。它基于 AVPlayerItem 和 AVAsset，为你提供了颗粒度更细的权限来获取资源，比如选择指定的音轨。它还通过 AVQueuePlayer 子类支持播放列表，而且你可以控制这些资源是否能够通过 AirPlay 发送。</p>
<h4 id="与-AVAudioPlayer-最主要的区别是，AVPlayer-对来自网络的流媒体资源的-“开箱即用”-支持。这增加了处理播放状态的复杂性，但是你可以使用-KVO-来观测所有的状态参数来解决这个问题。"><a href="#与-AVAudioPlayer-最主要的区别是，AVPlayer-对来自网络的流媒体资源的-“开箱即用”-支持。这增加了处理播放状态的复杂性，但是你可以使用-KVO-来观测所有的状态参数来解决这个问题。" class="headerlink" title="与 AVAudioPlayer 最主要的区别是，AVPlayer 对来自网络的流媒体资源的 “开箱即用” 支持。这增加了处理播放状态的复杂性，但是你可以使用 KVO 来观测所有的状态参数来解决这个问题。"></a>与 AVAudioPlayer 最主要的区别是，AVPlayer 对来自网络的流媒体资源的 “开箱即用” 支持。这增加了处理播放状态的复杂性，但是你可以使用 KVO 来观测所有的状态参数来解决这个问题。</h4><blockquote>
<p> AVAudioEngine</p>
</blockquote>
<p>AVAudioEngine 是播放和录制的 Objective-C 接口。它提供了以前需要深入到 Audio Toolbox 框架的 C API 才能做的控制 (例如一些实时音频任务)。该音频引擎 API 对底层的 API 建立了优秀的接口。如果你不得不处理底层的问题，你仍然可以使用 Audio Toolbox 框架。</p>
<p>这个 API 的基本概念是建立一个音频的节点图，从源节点 (播放器和麦克风) 以及过处理 (overprocessing) 节点 (混音器和效果器) 到目标节点 (硬件输出)。每一个节点都具有一定数量的输入和输出总线，同时这些总线也有良好定义的数据格式。这种结构使得它非常的灵活和强大。而且它集成了音频单元 (audio unit)。</p>
<h2 id="2-3-Media-Player-框架"><a href="#2-3-Media-Player-框架" class="headerlink" title="2.3 Media Player 框架"></a>2.3 Media Player 框架</h2><h4 id="2-3-1-场景特点"><a href="#2-3-1-场景特点" class="headerlink" title="2.3.1 场景特点"></a>2.3.1 场景特点</h4><p>众所周知音乐是iOS的重要组成播放，无论是iPod、iTouch、iPhone还是iPad都可以在iTunes购买音乐或添加本地音乐到音乐库中同步到你的iOS设备。在MediaPlayer.frameowork中有一个MPMusicPlayerController用于播放音乐库中的音乐。Media Player 框架是 iOS 平台上一个用于音频和视频播放的高层级接口，它包含了一个你可以在应用中直接使用的默认的用户界面。你可以使用它来播放用户在 iPod 库中的项目，或者播放本地文件以及网络流。这个框架也包括了查找用户媒体库中内容的 API，同时还可以配置像是在锁屏界面或者控制中心里的音频控件。</p>
<h4 id="2-3-2-使用方式"><a href="#2-3-2-使用方式" class="headerlink" title="2.3.2 使用方式"></a>2.3.2 使用方式</h4><p>使用MPMusicPlayerController实例化对象来播放内置音乐库的媒体文件，有以下两种类方法来实例化对象：</p>
<p>MPMusicPlayerController *playController = [MPMusicPlayerController systemMusicPlayer]; </p>
<p>说明：播放内置媒体库项目取代用户目前播放状态（如果是用网易云音乐或QQQ音乐在播放歌曲）</p>
<p>MPMusicPlayerController *playController = [MPMusicPlayerController applicationMusicPlayer]; </p>
<p>说明：播放该应用内的歌曲，不影响本机自带音乐播放器的状态。</p>
<ul>
<li><p>判断有没有正在播放的媒体</p>
<pre><code>[MPMusicPlayerController indexOfNowPlayingItem] == NSNotFound
</code></pre></li>
<li><p>创建媒体队列</p>
<pre><code>[MPMediaQuery songsQuery];
[MPMusicPlayerController setQueueWithQuery:nil];
</code></pre></li>
<li><p>获取媒体曲目的信息</p>
</li>
</ul>
<pre><code>MPMediaItem *currentItem = ....
NSString *artist = [currentItem valueForProperty:MPMediaItemPropertyArtist];
NSString *songName = [currentItem valueForProperty:MPMediaItemPropertyTitle];
</code></pre><ul>
<li><p>监听媒体通知</p>
<pre><code>NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];[notificationCenter addObserver:self
              selector:@selector()
                       name:MPMusicPlayerControllerNowPlayingItemDidChangeNotification
                     object:nil];
</code></pre></li>
</ul>
<h2 id="2-4-更多音频方案"><a href="#2-4-更多音频方案" class="headerlink" title="2.4 更多音频方案"></a>2.4 更多音频方案</h2><p>CoreAudio的接口层次：</p>
<p><img src="/assets/images/api.png" alt=""></p>
<h4 id="2-4-1-OpenAL"><a href="#2-4-1-OpenAL" class="headerlink" title="2.4.1 OpenAL"></a>2.4.1 OpenAL</h4><p>OpenAL 是一个跨平台的 API。它提供了位置 (3D) 和低延迟的音频服务。它主要用于跨平台游戏的开发。它有意地模仿了 OpenGL 中 API 的风格。</p>
<h4 id="2-4-2-Audio-Unit-框架"><a href="#2-4-2-Audio-Unit-框架" class="headerlink" title="2.4.2  Audio Unit 框架"></a>2.4.2  Audio Unit 框架</h4><p>Audio Unit 框架是一个底层的 API；所有 iOS 中的音频技术都构建在 Audio Unit 这个框架之上。音频单元是用来加工音频数据的插件。一个音频单元链叫做音频处理图。</p>
<p>如果你需要非常低的延迟 (如 VoIP 或合成乐器)、回声消除、混音或者音调均衡的话，你可能需要直接使用音频单元，或者自己写一个音频单元。但是其中的大部分工作可以使用 AVAudioEngine 的 API 来完成。如果你不得不写自己的音频单元的话，你可以将它们与 AVAudioUnit 节点一起集成在 AVAudioEngine 处理图中。</p>
<h4 id="2-4-2-AudioToolBox-框架"><a href="#2-4-2-AudioToolBox-框架" class="headerlink" title="2.4.2 AudioToolBox 框架"></a>2.4.2 AudioToolBox 框架</h4><p>通过AudioToolbox框架，可以将短声音注册到system sound服务上，被注册到system sound服务上的声音称之为 system sounds。<br>前面常用的System Sound Services 就来自这里的框架。</p>
<p>它必须满足下面几个条件：</p>
<p>(1).播放的时间不能超过30秒</p>
<p>(2).数据必须是 PCM或者IMA4流格式</p>
<p>(3).必须被打包成下面三个格式之一：Core Audio Format (.caf), Waveform audio (.wav), 或者 Audio Interchange File (.aiff)</p>
<p>(4）声音文件必须放到设备的本地文件夹下面。通过AudioServicesCreateSystemSoundID方法注册这个声音文件.</p>
<h4 id="2-4-3-CoreMIDI-和-CoreAudioKit-框架"><a href="#2-4-3-CoreMIDI-和-CoreAudioKit-框架" class="headerlink" title="2.4.3 CoreMIDI 和 CoreAudioKit 框架"></a>2.4.3 CoreMIDI 和 CoreAudioKit 框架</h4><p>在 iOS 上，Core MIDI 和 CoreAudioKit 可以被用来使应用程序表现为 MIDI 设备。在 OS X 上，Music Sequencing 服务提供了基于 MIDI 的控制和对音乐数据访问的权限。Core MIDI 服务为服务器和驱动程序提供了支持。</p>
<h4 id="2-4-4-QTKit-和-QuickTime-框架"><a href="#2-4-4-QTKit-和-QuickTime-框架" class="headerlink" title="2.4.4 QTKit 和 QuickTime 框架"></a>2.4.4 QTKit 和 QuickTime 框架</h4><p>现在已经过时了，它们不应该被用在以后的开发中。我们应该使用 AVFoundation (和 AVKit) 来代替它们</p>
<h1 id="三、今日头条嘉宾聊天室音频实践"><a href="#三、今日头条嘉宾聊天室音频实践" class="headerlink" title="三、今日头条嘉宾聊天室音频实践"></a>三、今日头条嘉宾聊天室音频实践</h1><h2 id="3-1-背景"><a href="#3-1-背景" class="headerlink" title="3.1 背景"></a>3.1 背景</h2><p>嘉宾聊天室是头条16年初新起的一个项目服务，目标是为了引进明星嘉宾访谈类型和体育赛事线上直播的节目，丰富头条在直播领域的内容，聊天室一期是属于图文、语音、短视频直播，后期发展可成为视频线上直播。表现形式与网易直播频道类似，但更丰富。</p>
<h2 id="3-2-IOS端实现"><a href="#3-2-IOS端实现" class="headerlink" title="3.2 IOS端实现"></a>3.2 IOS端实现</h2><p>根据聊天室在语音和视频的需求，使用系统自带实现的MPMoviePlayerController没法符合自定义的需求，包括功能与交互设计，并且MPMoviePlayerController已经不被苹果官方提倡，将要通过AVPlayer方案代替。需求本身的属于基本的语音和视频沟通，只对音频视频的录制与播放，符合音质画质要求和大小要求，因此采用AVFoundation框架即可，能够满足聊天室的需求。主要使用了AVPlayer、AVAudioRecorder、AVAudioSession等主要的类。</p>
<p>实现类有如下等：</p>
<pre><code>#import &quot;TTAudioRecorder.h&quot;
#import &quot;TTAudioPlayer.h&quot;
#import &quot;TTLiveCameraViewController.h&quot;
#import &quot;TTUploadVideoAudioManager.h&quot;
#import &quot;TTLiveAudioManager.h&quot;
</code></pre><h2 id="3-3-问题与解决"><a href="#3-3-问题与解决" class="headerlink" title="3.3 问题与解决"></a>3.3 问题与解决</h2><p>整个需求的实现过程还算顺利，按照API说明理解即可，提两三点说明下都会遇见哪一类的问题。</p>
<h4 id="3-1-音频格式为AMR"><a href="#3-1-音频格式为AMR" class="headerlink" title="3.1 音频格式为AMR"></a>3.1 音频格式为AMR</h4><p>AVPlayer来播放视频音频都相当强大，但是它也存在着一些不可回避的问题，那就是目前IOS已经不再支持AMR格式的播放。</p>
<pre><code>AMR format is no longer supported by Apple (since iOS 4.3)
</code></pre><p>与安卓同步开发的时候对接确立的通用的格式为AMR，因为AAC文件在网络传输下载播放的时候显得很大，AMR相对来说会好很多，同时我们也看了微博和微信的实现都是使用AMR，鉴于头条的用户量和使用体验，于是就采用了同样的方式。安卓可以很好支持AMR，在iOS平台上需要进行WAV和AMR之间的转换，好在libopencore可以解决这个事。网络上有好些所谓的相互转化的库，仔细看了下，都没有脱离这个core本身。</p>
<p>libopencore库：</p>
<pre><code>interf_dec.h 
interf_enc.h
dec_if.h
if_rom.h
libopencore-amrnb.a
libopencore-amrwb.a
</code></pre><p>主要方法：</p>
<pre><code>EncodeWAVEFileToAMRFile 、 DecodeAMRFileToWAVEFile
</code></pre><p>封装一个mannager：        </p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface VoiceConverter : NSObject

+ (int)amrToWav:(NSString*)_amrPath wavSavePath:(NSString*)_savePath;

+ (int)wavToAmr:(NSString*)_wavPath amrSavePath:(NSString*)_savePath;

@end
</code></pre><h4 id="3-2-WAV转化AMR声音变形："><a href="#3-2-WAV转化AMR声音变形：" class="headerlink" title="3.2 WAV转化AMR声音变形："></a>3.2 WAV转化AMR声音变形：</h4><p>录制WAV格式本地正常播放，转化为AMR后，把AMR格式文件在电脑端播放，声音严重变形，无法识别，再转化会WAV,，手机还是无法识别。<br>原因与解决<br>声音格式转化采用的是”amrFileCodec.h”，它对转化的音频输入源是有格式要求的，要求转化的采样率为标准的8k，如果录制的音频频率采用高频率44.1K的话就会出现变形，我想这里的设定依据来自于amr格式的采样率通常为8K。通过AVAudioRecorder把采样率设置为8K后，可以正常互相转化。</p>
<blockquote>
<p>AMR维基百科：</p>
<p>采样率 8 kHz/13-bit (160 采样点每20ms)，滤波后只保留 200-3400 Hz 范围内的信号.</p>
<p>编码器使用8个位速：12.2、10.2、7.95、7.40、6.70、5.90、5.15和4.75 kbit/s.</p>
</blockquote>
<pre><code>NSMutableDictionary *settings=[NSMutableDictionary dictionary];
[settings setObject:@(kAudioFormatLinearPCM) forKey:AVFormatIDKey];
[settings setObject:@(8000) forKey:AVSampleRateKey]; //必须和amr文件解码参数保持一致
[settings setObject:@(1) forKey:AVNumberOfChannelsKey];
[settings setObject:@(16) forKey:AVLinearPCMBitDepthKey];
[settings setObject:@(NO) forKey:AVLinearPCMIsFloatKey];
[settings setValue:@(NO) forKey:AVLinearPCMIsNonInterleaved];
[settings setValue:@(NO) forKey:AVLinearPCMIsBigEndianKey];
[settings setValue:@(AVAudioQualityHigh) forKey:AVEncoderAudioQualityKey];
AVAudioRecorder *recorderTemp = [[AVAudioRecorder alloc] initWithURL:fileUrl settings:settings error:nil];
</code></pre><h4 id="3-3-AVPlayer的准备状态"><a href="#3-3-AVPlayer的准备状态" class="headerlink" title="3.3 AVPlayer的准备状态"></a>3.3 AVPlayer的准备状态</h4><p>当AVPlayer的status变为AVPlayerStatusReadyToPlay后，依旧可能无法开始播放？</p>
<p>AVPlayerStatusReadyToPlay属性只是表明了AVPlayer已经成功的载入了AVPlayerItem，并且准备好，但是实际的是否能播放时由AVPlayerItem的status到达AVPlayerItemStatusReadyToPlay的时候，才能开始正常播放的。<br>如果我们的App使用CPU过多，I/O读写过多时，有可能导致直接无法播放，我们再调用play或者seekToTime:方法都无法正常播放，尤其是视频。所以我们需要做一个真正播放状态准备好的判断，也可以通过KVO去监听AVPlayerItem的status。</p>
<pre><code>//播放器是否准备好
if (self.videoPrePlayer.status == AVPlayerStatusReadyToPlay) 
{
    //视频是否加载成功
    if(self.videoPrePlayer.currentItem.status == AVPlayerItemStatusFailed){   
        return;
    }
        [self.videoPrePlayer play];

}
</code></pre><h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>文章主要对音频的使用范畴做了概括，并列举了两三实践点，其他的并没有做详细的论述，因为本篇比较偏向音频知识的介绍，知道用什么工具框架后再具体解决就好。比如如何播放流畅的网络音频，如何实现音频的快放与慢放等具体问题，此次需求内容并不复杂没有涉及，他们都可以通过 AudioToolBox框架实现。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-视频开发总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/28/视频开发总结/" class="article-date">
  	<time datetime="2015-01-28T11:09:59.000Z" itemprop="datePublished">Jan 28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/28/视频开发总结/">AVFoundation视频开发总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="IOS-视频录制-—-AVFoundation"><a href="#IOS-视频录制-—-AVFoundation" class="headerlink" title="IOS 视频录制 — AVFoundation"></a>IOS 视频录制 — AVFoundation</h1><p>AVFoundation是为数不多的几个框架,您可以使用和创建基于时间的视听媒体。它提供了一个objective - c接口用于工作与基于时间的视听数据详细的级别。例如,您可以使用它来检查,创建、编辑或reencode媒体文件。你也可以输入流从设备和操作视频实时捕捉和回放。</p>
<h2 id="一、概念引导："><a href="#一、概念引导：" class="headerlink" title="一、概念引导："></a>一、概念引导：</h2><h3 id="1、ASSets媒体文件"><a href="#1、ASSets媒体文件" class="headerlink" title="1、ASSets媒体文件:"></a>1、ASSets媒体文件:</h3><p>1）AVAsset</p>
<p>一个抽象类来表示时间等视听媒体视频和声音。每个资产包含一组跟踪旨在呈现或加工在一起,一个统一的媒体类型,包括但不限于音频、视频、文本、关闭字幕,字幕。</p>
<p>AVURLAsset *anAsset = [[AVURLAsset alloc] initWithURL:url options:nil];属性有<br>tracks、duration、preferredVolume、preferredTransform等等。</p>
<p>2) 一个AVAssetTrack</p>
<p>对象提供了所有资产提供track-level检查接口,方便对ASSets进行更具体的属性获取以及对应的操作。</p>
<p>3）AVAssetImageGenerator</p>
<p>对象提供缩略图或预览图像的资产独立于回放，可以生成单独的图片，也可以生成图片队列，这是获取视频缩略图的方式之一，还有另外两种ALAsset的thumbnail 和 - (UIImage *)imageFromSampleBuffer:(CMSampleBufferRef)sampleBuffer。</p>
<p>4）AVAssetExportSession</p>
<p>针对AVAsset源对象的内容进行转码，创建一个被指定输出形式的资源。</p>
<p><img src="/assets/images/AVAssetExportSession.jpg" alt=""></p>
<h3 id="2、Playback播放控制"><a href="#2、Playback播放控制" class="headerlink" title="2、Playback播放控制:"></a>2、Playback播放控制:</h3><p>1) AVPlayer</p>
<p>你使用一个AVPlayer对象来实现控制器和用户接口单一或多种条目回放。</p>
<ul>
<li><p>-  (instancetype)initWithPlayerItem:(AVPlayerItem *)item</p>
</li>
<li><p>play 、 parse 、 end</p>
</li>
<li><p>- (void)seekToTime:(CMTime)time</p>
</li>
</ul>
<p>2) AVPlayerLayer</p>
<p>用于显示视频内容，相当于大屏幕。里面有videoGravity，默认值 AVLayerVideoGravityResizeAspect.</p>
<p>3) AVPlayerItem</p>
<p>一个AVPlayerItem代表资产的表现状态,由一个AVPlayer对象和可以观察到的状态。对视频播放状态修改一起监听的过程多数发生在正对这个对象的操作操作上，比如：</p>
<ul>
<li>seekToTime，从哪里开始播放</li>
<li>各种资源播放状态的通知AVPlayerItemFailedToPlayToEndTimeNotification<br>等</li>
</ul>
<p>4) AVPlayerItemTrack </p>
<p>你用一个AVPlayerItemTrack对象修改资产的表现状态跟踪(AVAssetTrack)一个AVPlayer对象。通常视频的加载播放有各种状态，我们需要KVO监听或者添加通知去知道播放器的准备、进行、暂停、停止等状态。</p>
<p>5) AVQueuePlayer</p>
<p>按照队列播放视频</p>
<ul>
<li><p>queuePlayerWithItems，</p>
</li>
<li><p>insertItem:(AVPlayerItem *)item</p>
<pre><code>afterItem:(AVPlayerItem *)afterItem
</code></pre></li>
</ul>
<h3 id="3、Editing资源编辑"><a href="#3、Editing资源编辑" class="headerlink" title="3、Editing资源编辑:"></a>3、Editing资源编辑:</h3><p>AVFoundation框架提供了一个功能丰富的组类促进视听资产的编辑。AVFoundation的编辑API的核心成分，就是一组追踪从一个或多个不同的媒体资产。AVMutableComposition类提供了一个接口,用于插入和删除操作的痕迹,以及管理自己时间排序。</p>
<p><img src="/assets/images/AVMutableComposition.jpg" alt=""></p>
<p>1）AVMutableComposition</p>
<p>是一个可变的AVComposition子类，当您想要从现有资产创建一个新的资源。你可以添加和删除跟踪,可以添加、删除和时间范围。<br>比如：</p>
<ul>
<li>– insertEmptyTimeRange：可以增加一段空白时间</li>
</ul>
<ul>
<li>– insertTimeRange:ofAsset:atTime:error:<br>插入的所有跟踪给定的时间范围内指定的资产到接收机。</li>
</ul>
<!-- -->
<pre><code>AVAsset *videoAsset = &lt;#AVAsset with at least one video track#&gt;;
AVAsset *anotherVideoAsset = &lt;#another AVAsset with at least one video track#&gt;;
// Get the first video track from each asset.
AVAssetTrack *videoAssetTrack = [[videoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];
AVAssetTrack *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:AVMediaTypeVideo] objectAtIndex:0];
// Add them both to the composition.
[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:nil];
[mutableCompositionVideoTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:nil];&apos;
</code></pre><p>2) AVMutableAudioMix </p>
<p>一个AVMutableAudioMix对象管理混合音轨的输入参数。它允许自定义音频处理在回放期间音轨或执行其他操作。</p>
<!--0-->
<pre><code>AVMutableAudioMix *mutableAudioMix = [AVMutableAudioMix audioMix];
// Create the audio mix input parameters object.
AVMutableAudioMixInputParameters *mixParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:mutableCompositionAudioTrack];
// Set the volume ramp to slowly fade the audio out over the duration of the composition.
[mixParameters setVolumeRampFromStartVolume:1.f toEndVolume:0.f timeRange:CMTimeRangeMake(kCMTimeZero, mutableComposition.duration)];
// Attach the input parameters to the audio mix.
mutableAudioMix.inputParameters = @[mixParameters];
</code></pre><h3 id="4、Media-Capture媒体捕捉"><a href="#4、Media-Capture媒体捕捉" class="headerlink" title="4、Media Capture媒体捕捉:"></a>4、Media Capture媒体捕捉:</h3><p>1) AVCaptureDevice </p>
<p>代表输入设备,如摄像头或麦克风</p>
<p>2) AVCaptureInput </p>
<p>输入设备的配置端口，我们可以理解为输入</p>
<p>3）AVCaptureSession</p>
<p>协调数据流从输入到输出,用startRunning开始从输入到输出的数据流,并调用stopRunning停止流动。采取关闭代理，保证取景器一直流动。</p>
<p>4) AVCaptureOutput </p>
<ul>
<li><p>AVCaptureMovieFileOutput，输入到视频文件，代理AVCaptureFileOutputRecordingDelegate</p>
</li>
<li><p>AVCaptureVideoDataOutput，如果想要实时的处理每一帧数据，或想要有自己的图形动画，代理AVCaptureVideoDataOutputSampleBufferDelegate</p>
</li>
</ul>
<ul>
<li><p>AVCaptureAudioDataOutput ，音频数据，代理AVCaptureVideoDataOutputSampleBufferDelegate</p>
</li>
<li><p>AVCaptureStillImageOutput ，图片数据</p>
</li>
</ul>
<p>5）AVCaptureVideoPreviewLayer </p>
<p>实时展示被session传出出来的视频流数据，也就是我们的取景器</p>
<p>6）AVCaptureConnection </p>
<p>代表捕获之间的连接输入和输出对象关联到一个捕获会话。</p>
<p><img src="/assets/images/AVCaptureConnection.jpg" alt=""></p>
<h3 id="5、Export媒体输出"><a href="#5、Export媒体输出" class="headerlink" title="5、Export媒体输出:"></a>5、Export媒体输出:</h3><p>1) AVAssetExportSession</p>
<p>针对AVAsset对象转码，创建一个输出的形式被指定出口预设内容。包括对输出媒体资源的属性设定，可以设置presetName进行视频品质压缩，AVAssetExportPresetLowQuality等。也可以设置属性包括：outputFileType<br>、fileLengthLimit、timeRange<br>等。</p>
<p>2）AVAssetReader </p>
<p>直接从媒体读取存储样本,获得样本解码成可渲染的形式。组合资产多个音轨和组合多个视频跟踪(通过使用AVAssetReaderAudioMixOutput和AVAssetReaderVideoCompositionOutput)。</p>
<ul>
<li>addOutPut</li>
<li>startReading</li>
<li>cancelReading</li>
</ul>
<p>读取一个音频：</p>
<!--0-->
<pre><code>AVAudioMix *audioMix = &lt;#An AVAudioMix that specifies how the audio tracks from the AVAsset are mixed#&gt;;
// Assumes that assetReader was initialized with an AVComposition object.
AVComposition *composition = (AVComposition *)assetReader.asset;
// Get the audio tracks to read.
NSArray *audioTracks = [composition tracksWithMediaType:AVMediaTypeAudio];
// Get the decompression settings for Linear PCM.
NSDictionary *decompressionAudioSettings = @{ AVFormatIDKey : [NSNumber numberWithUnsignedInt:kAudioFormatLinearPCM] };
// Create the audio mix output with the audio tracks and decompression setttings.
AVAssetReaderOutput *audioMixOutput = [AVAssetReaderAudioMixOutput assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];
// Associate the audio mix used to mix the audio tracks being read with the output.
audioMixOutput.audioMix = audioMix;
// Add the output to the reader if possible.
if ([assetReader canAddOutput:audioMixOutput])
[assetReader addOutput:audioMixOutput];
</code></pre><p>3) AVAssetWriter</p>
<p>使用一个AVAssetWriter对象媒体数据写入新文件指定视听的容器类型,如QuickTime电影文件或一个mp4文件,支持自动交叉媒体数据的多个并发的痕迹。</p>
<ul>
<li>initWithURL:fileType:error:</li>
<li>startWriting</li>
<li>startSessionAtSourceTime</li>
<li>addInput</li>
<li>endSessionAtSourceTime</li>
<li>finishWritingWithCompletionHandler</li>
</ul>
<h2 id="二、代码实践："><a href="#二、代码实践：" class="headerlink" title="二、代码实践："></a>二、代码实践：</h2><blockquote>
<h3 id="import-“TTCameraViewController-h”"><a href="#import-“TTCameraViewController-h”" class="headerlink" title="#import “TTCameraViewController.h”"></a>#import “TTCameraViewController.h”</h3></blockquote>
<h2 id="三、问题回顾："><a href="#三、问题回顾：" class="headerlink" title="三、问题回顾："></a>三、问题回顾：</h2><h3 id="1、视频文件写入崩溃："><a href="#1、视频文件写入崩溃：" class="headerlink" title="1、视频文件写入崩溃："></a>1、视频文件写入崩溃：</h3><h4 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h4><p>相机开始拍摄就会出现崩溃，时而出现，有时难以复现。</p>
<h4 id="原因与解决："><a href="#原因与解决：" class="headerlink" title="原因与解决："></a>原因与解决：</h4><p>1）startSessionAtSourceTime只能在 AVAssetWriterStatusWriting的之后调用，但是startWriting调用之后writer并没有立即变为writing状态，而已有一个极短的开始时间，参照苹果规范使用文档，只需要前面调用之后后面就可以跟着执行startSessionAtSourceTime，然而，我遇见了这问题，说明它并不是。随后我到stackoverflow上查了问题，发现有人早就提过，并没有答案，说是升级IOS8以后就没有了，可我这里是IOS9…随后我只能判断writer状态如果是writing就开始执行，如果不是就调用startWriting。</p>
<p>2）[videoWriterInput appendSampleBuffer：xxx]这只能在startSessionAtSourceTime开始之后调用，和1是同样的情况，明明第一行调用了startSessionAtSourceTime，第二调用appendSampleBuffer就会崩溃，并且依旧是偶尔发生。但是这里的问题是没有一个状态可以判断是否已经开始startSessionAtSourceTime，这里就有点血崩了，不能像问题1一样判断解决，后来只好try catch了,稳住局面防止崩溃，丢失极少的毫秒级帧数。</p>
<h3 id="2、相机拍摄闪烁抖动："><a href="#2、相机拍摄闪烁抖动：" class="headerlink" title="2、相机拍摄闪烁抖动："></a>2、相机拍摄闪烁抖动：</h3><h4 id="现象：-1"><a href="#现象：-1" class="headerlink" title="现象："></a>现象：</h4><p>开始拍摄时候，取景器闪烁抖动，引起一小部分可见范围内的视频内容发送抖动，并被存入文件中，体验差。</p>
<h4 id="原因与解决：-1"><a href="#原因与解决：-1" class="headerlink" title="原因与解决："></a>原因与解决：</h4><p>在开始拍摄的时候，再去创建connection并传递设备和拍摄方向，有利于视频获取oritation，自然而然的横着拍摄也会竖着播放，但是问题在于connection的建立产生较大的链接，引起视频抖动，此抖动将被录制进入视频文件中。于是我采取在初始化input的时候就把connection就增加进去，当开始拍摄的时候不会发生抖动，但是牺牲的是视频的oritation需要自己根据用户拍摄的方向去手动修改视频方向。</p>
<h3 id="3、视频方向混乱："><a href="#3、视频方向混乱：" class="headerlink" title="3、视频方向混乱："></a>3、视频方向混乱：</h3><h4 id="现象：-2"><a href="#现象：-2" class="headerlink" title="现象："></a>现象：</h4><p>背面摄像头拍摄，home键在下，拍摄出来的视频文件，在播放的时候，底部在手机右边，而不是底边，一次类推，home键在底部与视频的底部角度成90垂直关系。</p>
<h4 id="原因与解决：-2"><a href="#原因与解决：-2" class="headerlink" title="原因与解决："></a>原因与解决：</h4><!--0-->
<pre><code>self.videoOutPut = [[AVCaptureVideoDataOutput alloc] init];
NSDictionary * outputSettings = [[NSDictionary alloc] initWithObjectsAndKeys:[NSNumber numberWithInt:kCVPixelFormatType_32BGRA],(id)kCVPixelBufferPixelFormatTypeKey, nil];
[self.videoOutPut setVideoSettings:outputSettings];

//必须
if ([self.session canAddOutput:self.videoOutPut]) {
    [self.session addOutput:self.videoOutPut];
}

//先于
self.videoConnection = [self.videoOutPut connectionWithMediaType:AVMediaTypeVideo];
self.videoConnection.enabled = NO;
[self.videoConnection setVideoOrientation:AVCaptureVideoOrientationPortrait];
</code></pre><h3 id="4、横着拍摄的视频横着播放："><a href="#4、横着拍摄的视频横着播放：" class="headerlink" title="4、横着拍摄的视频横着播放："></a>4、横着拍摄的视频横着播放：</h3><h4 id="现象：-3"><a href="#现象：-3" class="headerlink" title="现象："></a>现象：</h4><p>横着拍摄的视频，放的时候是竖着的。</p>
<h4 id="原因与解决：-3"><a href="#原因与解决：-3" class="headerlink" title="原因与解决："></a>原因与解决：</h4><p>因为上面解决视频抖动，导致不能直接设定拍摄时候的视频方向，从而需要根据手动的拍摄方向去修改视频的视图的方向。<br>考虑到用户可能锁住屏幕旋转，于是就CMMotionManager获取重力方向来判断，在VC出现或者开始拍摄的时候开启，在VC退出或者拍摄完成的的时候关闭。获得方向后，在视频的写入里直接修改方向即可。</p>
<!--0-->
<pre><code>[videoWriterInput setTransform:CGAffineTransformScale(CGAffineTransformMakeRotation(-M_PI_2), 1.0, 1.0)];
</code></pre><h3 id="5、录制视频有右边和底边绿色线条："><a href="#5、录制视频有右边和底边绿色线条：" class="headerlink" title="5、录制视频有右边和底边绿色线条："></a>5、录制视频有右边和底边绿色线条：</h3><h4 id="现象：-4"><a href="#现象：-4" class="headerlink" title="现象："></a>现象：</h4><p>手机全屏录制的时候，设置视频输出宽度为手机的宽高，当宽高为基数的时候视频录制里面会出现绿色线条。</p>
<h4 id="原因与解决：-4"><a href="#原因与解决：-4" class="headerlink" title="原因与解决："></a>原因与解决：</h4><p>不知道原因，神奇的bug，参照着段子的视频方法解决的，直接修改视频输出宽高为偶数。</p>
<!--0-->
<pre><code>NSInteger videoWidth = [[NSNumber numberWithFloat:self.view.frame.size.width] integerValue];
NSInteger videoHeight = [[NSNumber numberWithFloat:self.view.frame.size.height] integerValue];
if (videoWidth % 2 == 1) {
    videoWidth = videoWidth - 1;
}
if (videoHeight % 2 == 1) {
    videoHeight = videoHeight - 1;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-RunLoop是如何跑起来的" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/05/RunLoop是如何跑起来的/" class="article-date">
  	<time datetime="2015-01-05T06:34:12.000Z" itemprop="datePublished">Jan 5</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/05/RunLoop是如何跑起来的/">RunLoop是如何跑起来的</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="对-Run-Loop-的理解"><a href="#对-Run-Loop-的理解" class="headerlink" title="对 Run Loop 的理解"></a>对 Run Loop 的理解</h1><h2 id="一、Run-Loop为何存在"><a href="#一、Run-Loop为何存在" class="headerlink" title="一、Run Loop为何存在?"></a>一、Run Loop为何存在?</h2><p>我们从编写命令式的语句开始理解，一般我们写一个运行函数，只要顺序执行，一遍就过了，比如简单的NSLog一个“hello word”，这样我们就算完成了一个问候世界的程序。好简单的程序，但是一个复杂的系统，一个能称之为系统的程序，比如我们的手机App，它是不可能按照执行顺序一下执行完成就结束的，它包含了我们各类需求，会接受我们不同的操作，所以这个程序需要有一个设计的模式能够符合这样的应用场景，能够响应操作。所以，有了Event驱动的模式。</p>
<p>特点：</p>
<ul>
<li>程序可以一直运行并且接受用户的输入</li>
<li>决定程序应该处理哪些Event</li>
<li>主调方不能被被调方卡主，所以需要调用解耦。主调方就发个消息就完事了，就不管了，就可以去做别的了，被调防根据消息去派发、操作等等。这个概念就是(Message Queue) </li>
<li>节省了CPU时间，比如时间片执行，这就是操作系统里的概念。</li>
<li>没事的时候闲着，有事的时候激活它</li>
</ul>
<h2 id="二、Run-Loop-都包含了什么相关内容？"><a href="#二、Run-Loop-都包含了什么相关内容？" class="headerlink" title="二、Run Loop 都包含了什么相关内容？"></a>二、Run Loop 都包含了什么相关内容？</h2><h3 id="1、CF层和F层"><a href="#1、CF层和F层" class="headerlink" title="1、CF层和F层"></a>1、CF层和F层</h3><p>CF层是C写的，跨平台，F层其实不干事的。GCD 有部分联系。</p>
<p><img src="/assets/images/RL_CF.jpg" alt=""></p>
<h3 id="2、常用"><a href="#2、常用" class="headerlink" title="2、常用"></a>2、常用</h3><p>NSTimer 完全依赖于RunLoop，UIEvent 都是RunLoop 跑的，AutoRelease 面试问题</p>
<p><img src="/assets/images/RL_normal.jpg" alt=""></p>
<h2 id="三、RunLoop调用堆栈"><a href="#三、RunLoop调用堆栈" class="headerlink" title="三、RunLoop调用堆栈"></a>三、RunLoop调用堆栈</h2><p><img src="/assets/images/RL_zhan.jpg" alt=""></p>
<h2 id="四、RunLoop构成元素"><a href="#四、RunLoop构成元素" class="headerlink" title="四、RunLoop构成元素"></a>四、RunLoop构成元素</h2><h3 id="1、构成元素"><a href="#1、构成元素" class="headerlink" title="1、构成元素"></a>1、构成元素</h3><p>thread里面不是只能起一个RL，是可以多个的，但是必须嵌套。<br>RunLoop机制存在的一对多的关系，比如Mode和Timer<br>CFRunLoopSurece、CFRunLoopTimer、CFRunLoopObserver，主要的核心就是这三个。</p>
<p><img src="/assets/images/RL_consist.jpg" alt=""></p>
<h3 id="2、对CFRunLoopTimer的封装"><a href="#2、对CFRunLoopTimer的封装" class="headerlink" title="2、对CFRunLoopTimer的封装"></a>2、对CFRunLoopTimer的封装</h3><p>NSTimer、 performSelector:after 、 displayLink</p>
<h3 id="3、对CFRunLoopSurece的理解"><a href="#3、对CFRunLoopSurece的理解" class="headerlink" title="3、对CFRunLoopSurece的理解"></a>3、对CFRunLoopSurece的理解</h3><p>source是RL的数据源的抽象类，类似proctol，定义了两个version的source：</p>
<ul>
<li>source0：处理APP内部的世界、APP自己管理触发，比如UIEvent、CFSocket</li>
<li>source1: 又RL和内核管理，Mach port 驱动 ，进程兼通讯的方式，往某个进程方法可以发到这个port上，对面的进程监听这个port 就是可以获得消息。比如：CFMachPort，CFMessagePort</li>
</ul>
<p><img src="/assets/images/RL_Source0.jpg" alt=""></p>
<h3 id="4、对CFRunLoopServer对外报告状态"><a href="#4、对CFRunLoopServer对外报告状态" class="headerlink" title="4、对CFRunLoopServer对外报告状态"></a>4、对CFRunLoopServer对外报告状态</h3><p>比如我们在CAAnimation数组，多个动画，RL会通过判断依次的状态，将全部收集到一起后再开始执行。</p>
<p><img src="/assets/images/RL_Observer.jpg" alt=""></p>
<h3 id="5、CFRunLoopMode"><a href="#5、CFRunLoopMode" class="headerlink" title="5、CFRunLoopMode"></a>5、CFRunLoopMode</h3><p>RunLoop在同一时间段内，只能在唯一的特点的mode下Run。<br>更换Mode时，需要停止当前的Loop，然后重启动新的Loop。<br>Mode是个保证IOS滑动顺畅的关键，在这个mode下只执行滑动计算相关<br>可以创建自己的mode</p>
<p>NSDefaultRunLoopMode: 默认的<br>UITrackingRunLoopMode:scrollView滑动<br>UIInitializationRunLoopMode: 启动的时候，私有的<br>NSRunLoopCommomModes: 1和2都能执行，作为一个数组，并无优先级</p>
<blockquote>
<p>相关Topic：</p>
</blockquote>
<ul>
<li><p>NSTimer 默认被加入NSDefaultRunLoopMode中，如果不希望被SCrollView影响，让滑动的时候timer也依然进行运行，就需要添加到NSRunLoopCommomModes中。</p>
</li>
<li><p>RunLoopMode切换<br>都是重新起，不是切换回原来的</p>
</li>
</ul>
<p><img src="/assets/images/RL_Mode_Change.jpg" alt=""></p>
<ul>
<li>GCD和Run Loop的联系</li>
</ul>
<p>GCD的计时器是它自己的计时器，只有main queue的时候有关系。Run Loop 会问一下 GCD 你这边在搞事情吗？有的话就抛出来。</p>
<p><img src="/assets/images/RL_GCD.jpg" alt=""></p>
<ul>
<li>Auto Release<br>UIKit 通过的RunLoopServer在RunLoop两次Sleep间对Autorelease进行Pop和Push将这次Loop中产生的AutoRelease对象释放。两圈之间自动释放UI上自动释放池的东西，比如UITouch。</li>
</ul>
<h3 id="六、RunLoop的挂起和唤醒"><a href="#六、RunLoop的挂起和唤醒" class="headerlink" title="六、RunLoop的挂起和唤醒"></a>六、RunLoop的挂起和唤醒</h3><p>CGRunLoopServiceMachPort 的作用就是发送消息，表示暂停还是激活，与内核进行交互。</p>
<p><img src="/assets/images/RL_Port.jpg" alt=""></p>
<h3 id="七、RunLoop的实践"><a href="#七、RunLoop的实践" class="headerlink" title="七、RunLoop的实践"></a>七、RunLoop的实践</h3><p>1、AFNetworking<br>常驻线程，NSURLConnetion需要一个RL常驻，不然跑一次就没了。<br>比如有个需求需要一直在线程里面呆着。</p>
<pre><code>+ (void)networkRequestThreadEntryPoint:(id)__unused object {
@autoreleasepool {
    [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];

    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
    [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
    [runLoop run];
}
}
+ (NSThread *)networkRequestThread {
static NSThread *_networkRequestThread = nil;
static dispatch_once_t oncePredicate;
dispatch_once(&amp;oncePredicate, ^{
    _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
    [_networkRequestThread start];
});

return _networkRequestThread;
</code></pre><p>}</p>
<p>2、 延迟加载tableview的图片</p>
<pre><code>UIImage *downLoadImage = ...;  
[self.avatarImageView performSelector:@selector(setImage:)  
                    withObject:downloadImage  
                    afterDelay:0  
                    inModes:@[NSDefaultRunLoopMode]];
</code></pre><p>3、让Crash的APP回光返照</p>
<pre><code>// 创建RunLoop
CFRunLoopRef runLoop = CFRunLoopGetCurrent();
// 设置Mode
NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runLoop));
// 弹窗告知 程序挂了
UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;程序崩溃了&quot; message:@&quot;崩溃信息&quot; delegate:nil cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:nil];
[alertView show];
while (1) {
for (NSString *mode in allModes) {
// 快速的切换 Mode  就能处理滚动、点击等事件
CFRunLoopRunInMode((CFStringRef)mode, 0.001, false);
}
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Hexo-个人博客使用介绍" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/07/Hexo-个人博客使用介绍/" class="article-date">
  	<time datetime="2014-11-07T11:09:59.000Z" itemprop="datePublished">Nov 7</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/07/Hexo-个人博客使用介绍/">Hexo一下，博客诞生</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="个人博客搭建推荐Hexo"><a href="#个人博客搭建推荐Hexo" class="headerlink" title="个人博客搭建推荐Hexo"></a>个人博客搭建推荐Hexo</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>事实上，好早之前就尝试过自己搭建的个人博客，想积累写写技术知识点和生活上的见闻，希望它作为自己个人的一块土地。通常我们会在一些博客网站注册，比如博客园，然后开始作文，但这样的博客网站的界面UI设计挺糟糕的，作为还有一些审美的我是真的不太乐意去使用，虽然同为苦逼码农。后来出了一些品质比较高的静态博客等，也尝试去使用过，最后还是选择了使用博客组件去搭建，因为总觉得独立的才是自己的，大概程序员的内心都流淌着这样的独白。</p>
<p>博客搭建框架组件很多，从WordPress到FarBox、Jekyll、Octopress、ghost、marboo、Hexo等等，他们基本都配合github使用,在网上各路大神的推荐之下，试过几款框架,基本都是在读完安装说明并开始有点小激动的时候，痛苦的安装过程让我放弃了这一方式。现在回想，一方面是由于自己前两年的电脑和网络都很烂，另一方面也是自己年轻没经验，搭建过程很多东西都需要一点点的搜索去学习，电脑一卡一慢就各种不爽，是真卡，我那个笔记本啊，最后就GG了。不过最后我还是搭建了自己的博客，并没有使用上述的哪种框架,前面的过程学习并知道了博客的搭建方式，索性自己就用FW设计了个人博客的UI界面，正好也会前端FE，就手写了博客页面Css和JS，这样博客的结界面就出来了，自己动手丰衣足食，然而它只是个静态的…到编译这一环节过不去了，毕竟JS属于前端的江湖，咋整…于是找了个python脚本，动态编译产生静态文件，只需要专心的写文字就好，随后可上传到github通过域名映射直接展示。这样，我就搭建好了自己的博客，界面都是我自己设计后用代码自己一行一行写的啊，简直高端大气上档次，简直满意的不得了！结果是非常符合我自己的审美设计要求，内心那个开心呐，随后开始了我的博客之路。</p>
<p>到后来接触了Hexo,它就是我上述过程的一个更为优化的方案，功能完善，扩展强大。通过Hexo的使用也发现上手很快，我几乎是在半小时就搭建完成了博客，这速度让我为之欢呼，所以我决定转到Hexo来写作，那么，这里就写个文章来推荐一下吧。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><blockquote>
<p>安装说明</p>
</blockquote>
<h5 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h5><ul>
<li><p>你得有自己的域名，买域名的地方比较多，有的坑有的好，我是在godaddy上买的。</p>
</li>
<li><p>注册github账号，你将会免费使用到它提供的各种便利而强大的功能，免费的存储空间，下载开源项目等等。</p>
</li>
<li><p>把你的域名映射到github默认的博客地址上。</p>
</li>
<li><p>安装Node.js, npm</p>
</li>
<li><p>安装git,生成SSH-KEY管理权限，配置域名到github关联</p>
</li>
</ul>
<h5 id="二、安装Hexo"><a href="#二、安装Hexo" class="headerlink" title="二、安装Hexo"></a>二、安装Hexo</h5><p>1、hexo程序环境</p>
<blockquote>
<p>npm install -g hexo</p>
</blockquote>
<p>2、hexo工程</p>
<blockquote>
<p>$ hexo init 文件夹名称</p>
<p>$ cd 文件夹名称</p>
<p>$ npm install</p>
</blockquote>
<p>3、会得到文件夹目录</p>
<blockquote>
<p>├ ── _config.yml</p>
<p>├ ── package.json</p>
<p>├ ── scaffolds</p>
<p>├ ── source</p>
<p>├ ── _drafts</p>
<p>└ ── _posts</p>
<p>└ ── themes</p>
</blockquote>
<p>4、按照命令行操作，此时到这里，别管这些文件是干啥的，来，我们接着往下走。</p>
<h5 id="三、生成第一篇文章"><a href="#三、生成第一篇文章" class="headerlink" title="三、生成第一篇文章"></a>三、生成第一篇文章</h5><p>1、创建文章</p>
<blockquote>
<p>hexo new 你的文章名称</p>
</blockquote>
<p>2、编辑你的文章</p>
<p>上面一步在你对应的文件夹下新建了一个Markdown文件，此时需要你使用对应的语法去编写文档，不知道的可以去学习下，用语言命令号来写Word文档，该有的有，不该有的没有，简直就是最爱</p>
<p>3、编译</p>
<blockquote>
<p>hexo generate</p>
<p>hexo server</p>
</blockquote>
<p>此时打开你的浏览器，默认地址是（ <a href="http://0.0.0.0:4000/" target="_blank" rel="external">http://0.0.0.0:4000/</a> ），你就可以看到你的文章了，就是你刚才编写的文章。  </p>
<h5 id="四、发布到github"><a href="#四、发布到github" class="headerlink" title="四、发布到github"></a>四、发布到github</h5><p>由于前面你做好了准备工作，所以这里只需要</p>
<blockquote>
<p>git commit -a -m “<em>*</em>文章”</p>
<p>git push</p>
</blockquote>
<p>此时打开你的浏览器，比如你买的域名是( <a href="http://baidu.com/" target="_blank" rel="external">http://baidu.com/</a> )，你打开它，和你在（ <a href="http://0.0.0.0:4000" target="_blank" rel="external">http://0.0.0.0:4000</a> ）看到的一毛一样，可以发给你的朋友看了。 </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于Hexo的使用，前后只介绍了关键的几个命令，为了可以可以快速搭建，都是基础入门很方便，麻烦的到是前面的准备工作，得一步步挨着来，有不懂的可以搜索和咨询。Hexo可以更换主题，也可以参照他人的主题制作，比如本站的主题yilia就是从github上找的开源主题，作者是我科的学长，已经获得了近2000颗星，这就是开源的力量，感谢学长litten的贡献。Hexo的其他扩展功能，请直接浏览Hexo的官网学习，我这里就不做的翻译了。</p>
<!--![](/assets/images/aoteman.png)-->

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-引用计数MRC、ARC与属性修饰符" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/11/02/引用计数MRC、ARC与属性修饰符/" class="article-date">
  	<time datetime="2014-11-02T08:23:47.000Z" itemprop="datePublished">Nov 2</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/11/02/引用计数MRC、ARC与属性修饰符/">引用计数MRC、ARC与属性修饰符</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、MRC"><a href="#一、MRC" class="headerlink" title="一、MRC"></a>一、MRC</h2><h3 id="1、内存管理问题"><a href="#1、内存管理问题" class="headerlink" title="1、内存管理问题"></a>1、内存管理问题</h3><p>传统的内存管理方式都需要业务代码自己处理，比如C和C++,程序员自己控制对象的使用周期，进行生成和释放。随着代码越来越复杂和人员的流动，就会出现无法确定的代码，如果内存对象一直留在那里，没人敢释放，整个程序占用的空间越来越大；胆大的人释放了可能导致crash。尽管遵循一些“谁创建谁释放”、“谁持有谁释放” 的原则，但依旧导致存储空间的浪费：为了保留仅仅一个内存对象，却要将与它关联的一大堆对象保留住，然而其中大部分已经不再使用了。</p>
<h3 id="2、解决方式"><a href="#2、解决方式" class="headerlink" title="2、解决方式"></a>2、解决方式</h3><p>就是引用计数。所有使用到同一内存对象的地方，使用者只要保证自己 retain 一次，release 一次，不用管别人是否使用。这样就实现了内存管理的分离，这就是MRC。当你使用new、alloc、copy方法创建一个对象时，该对象的保留计数器值为1.当不再使用该对象时，你要负责向该对象发送一条release或autorelease消息。当这个对象本身的引用计数为0时，就会被系统销毁。如果还有别处对它的引用，它就还在继续存在。<br>所有的内存管理是需要程序员手写代码控制的，一般就是持有操作和释放操作。<br>原则：谁持有，谁释放，不持有，不能释放，不再需要时，主动释放。</p>
<h2 id="二、-ARC"><a href="#二、-ARC" class="headerlink" title="二、 ARC"></a>二、 ARC</h2><h3 id="1、本质"><a href="#1、本质" class="headerlink" title="1、本质"></a>1、本质</h3><p>ARC只是相对于MRC的一次改进，但它和之前的技术本质上没有区别。它会默认在程序代码合适的位置呗对象增加计数和释放计数对象，其实就是MRC那些繁琐的操作给默认自动化了。当然ARC本身的特性是有区别的。</p>
<p>ARC是编译器时特性，而不是运行时特性。系统在运行时统一管理所有内存对象的释放，会导致增加额外的内存和 CPU 开销，程序员们依然在努力降低内存和CPU消耗。</p>
<h3 id="2、开关切换"><a href="#2、开关切换" class="headerlink" title="2、开关切换"></a>2、开关切换</h3><p>在target中找到对应的文件可以进行配置。</p>
<p>打开ARC：-fobjc-arc<br>关闭ARC：-fno-objc-arc</p>
<h2 id="三、修饰符"><a href="#三、修饰符" class="headerlink" title="三、修饰符"></a>三、修饰符</h2><h3 id="1、属性修饰符"><a href="#1、属性修饰符" class="headerlink" title="1、属性修饰符"></a>1、属性修饰符</h3><h4 id="1-1-存取类型"><a href="#1-1-存取类型" class="headerlink" title="1.1 存取类型"></a>1.1 存取类型</h4><p>任何属性都可以声明为readwrite或readonly，且默认设置为readwrite。</p>
<p>readwrite：程序自动创建setter/getter方法。<br>readonly：程序之创建getter方法。<br>此外，还可以自定义setter/getter方法。</p>
<h4 id="1-2-原子性"><a href="#1-2-原子性" class="headerlink" title="1.2 原子性"></a>1.2 原子性</h4><p>atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。</p>
<h4 id="1-3-生命周期管理"><a href="#1-3-生命周期管理" class="headerlink" title="1.3 生命周期管理"></a>1.3 生命周期管理</h4><blockquote>
<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3></blockquote>
<ul>
<li>assign:</li>
</ul>
<p>默认类型。简单赋值，不更改引用计数。unsafe_unretained 修饰“基础数据类型”并不会报错，在实际使用时，与 assign 是完全等价的。</p>
<ul>
<li>copy:</li>
</ul>
<p>会拷贝传入的对象（即创建一个引用计数为1的新对象，但是内容与传入对象相同），并把新对象赋值给实例变量。常用与NSString,NSArray,NSDictionary,NSSet等。</p>
<ul>
<li>retain: </li>
</ul>
<p>释放旧对象，并使传入的新对象引用计数+1。此属性只能用于NSObject及其子类，而不能用于Core Foundation。</p>
<blockquote>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3></blockquote>
<ul>
<li>strong: </li>
</ul>
<p>默认类型，强引用，类似于retain。要求保留传入的对象，并放弃原有对象。</p>
<ul>
<li>weak: </li>
</ul>
<p>弱引用，不会使传入的对象引用计数+1。类似于assign，但与assign不同的是，当它们指向的对象被释放后，weak会被自动置为nil，而assign则不会，所以assign会导致“野指针”的出现，weak可以避免悬空指针。使用附有 weak 修饰符的变量会自动注册到 autoreleasepool。如果大量使用 weak 修饰的变量，则会消耗相应的 CPU 资源。良策是只在需要避免循环引用时使用 weak。</p>
<ul>
<li>unsafe_unretained: </li>
</ul>
<p>其实质等同于assign。与weak的区别就是指向的对象如果被释放，其不会被置为nil，而导致悬空指针的出现。它是ARC模式下非对象属性的默认值。</p>
<blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3></blockquote>
<ul>
<li><p>strong/retain,两者等价。</p>
</li>
<li><p>assign/unsafe_unretained，两者修饰非对象属性等价。</p>
</li>
<li><p>默认属性：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MRC：(atomic, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>)</span><br><span class="line">ARC下对象类型属性：(atomic, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>)</span><br><span class="line">ARC下非对象类型：(atomic, <span class="keyword">readwrite</span>, unsafe_unretained)</span><br></pre></td></tr></table></figure>
<h3 id="2、变量关键字修饰符"><a href="#2、变量关键字修饰符" class="headerlink" title="2、变量关键字修饰符"></a>2、变量关键字修饰符</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">_string:</span> 是默认引用类型的关键字。</span><br><span class="line"><span class="symbol">__weak:</span> 声明一个可以自动置nil的弱引用。</span><br><span class="line"><span class="symbol">__unsafe_unretained:</span> 弱引用，但是当指向对象被释放时，不会被置nil。所以会导致野指针的出现。</span><br><span class="line"><span class="symbol">__autoreleasing:</span>用来修饰一个函数的参数，这个参数会在函数返回的时候被自动释放。</span><br></pre></td></tr></table></figure>
<ul>
<li>对应关系：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">strong</span>：__<span class="keyword">strong</span>修饰符</span><br><span class="line">retain：__<span class="keyword">strong</span>修饰符</span><br><span class="line"><span class="keyword">assign</span>：__unsafe_unretained修饰符</span><br><span class="line">unsafe_unretained：__unsafe_unretained修饰符</span><br><span class="line"><span class="keyword">weak</span>：__<span class="keyword">weak</span>修饰符</span><br><span class="line"><span class="keyword">copy</span>：__<span class="keyword">strong</span>修饰符(但是赋值的是被复制的对象)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-前端FE速成" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/15/前端FE速成/" class="article-date">
  	<time datetime="2014-10-15T15:22:12.000Z" itemprop="datePublished">Oct 15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/15/前端FE速成/">FE进阶之路</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>转移动端开发之前，曾是名呆萌的FE，在学校的时候还算勤劳，上线了大大小小的产品，冰岩作坊见证了我的成长，认识了很多朋友。如今回顾一下，整理一条前端之路。</p>
</blockquote>
<h2 id="面试点"><a href="#面试点" class="headerlink" title="面试点"></a>面试点</h2><p><img src="/assets/images/feTotal.png" alt=""></p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="一、语言"><a href="#一、语言" class="headerlink" title="一、语言"></a>一、语言</h3><h3 id="1、HTML"><a href="#1、HTML" class="headerlink" title="1、HTML"></a>1、HTML</h3><h4 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h4><ul>
<li><p><code>HyperText Markup Language</code>超文本标记语言。语言自不必说，超文本意味着『将网页彼此连接链接，超越了传统意义上的书本文字』，标记则说明了语言的特点是描述性的。比如可以通过标签来描述内容：<code>&lt;h1&gt;</code>是一个标题(headline)；<code>&lt;p&gt;</code>是一个段落(paragraph)；<code>&lt;code&gt;</code>是一段代码等等。还可以通过声明属性进一步描述如<code>&lt;input class=&quot;form-inline&quot; id=&quot;gender-input-female&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt;</code>。HTML是一门应当注重语义化的语言，尤其在HTML5的规范中更是强调此，如增加了<code>&lt;article&gt;``&lt;section&gt;</code>等标签。</p>
</li>
<li><p>标签有自闭和和成对闭合两种，具体规则要参考规范，注意自闭合标签结尾的反斜杠不是必须的。常见的自闭合标签是<code>&lt;img&gt;</code>，<code>&lt;input&gt;</code>。</p>
</li>
<li><p>HTML在被浏览器渲染时，会有两种元素，非替换元素指的是其内容无需被浏览器替换，直接显示即可。而替换原素则需要浏览器进行转换才能正常工作，如<code>&lt;img&gt;&lt;textarea&gt;&lt;canvas&gt;</code></p>
</li>
<li><p>HTML中也可以嵌入如SVG等其他语言内容。</p>
</li>
</ul>
<h3 id="2、CSS"><a href="#2、CSS" class="headerlink" title="2、CSS"></a>2、CSS</h3><h4 id="2-1-理解"><a href="#2-1-理解" class="headerlink" title="2.1 理解"></a>2.1 理解</h4><ul>
<li><code>Cascading Style Sheets</code>层叠样式表。表自不必说，样式也是顾名思义，关键点在于层叠。CSS的层叠体现在选择器的关系上：通过选择器的优先级来决定样式的使用与否，能够灵活的控制HTML元素的样式。</li>
<li>一个普通的『规则』由如下部分组成：选择器+声明块（声明由属性：值组成），此外还有@语句，可用于媒体查询、引入文件等，在此略过。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.class</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(0,0,0,.6);</span><br><span class="line">    <span class="attribute">transition</span>: height .<span class="number">3s</span> ease-in-out .<span class="number">5s</span>;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.night</span> <span class="selector-class">.class</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由于浏览器纷争以及标准的制定落后于市场，CSS存在着很严重的兼容性问题。具体问题暂且不表，但为了解决这些问题，业界目前普遍使用『预处理器』和『后处理器』来增强CSS。</li>
</ul>
<p>a、 预处理器主要是通过对CSS进行改编或扩展行成一种新的语言，然后通过『预处理器』编译为可被浏览器使用的CSS。常见的就是LESS和SCSS。<br>b、 后处理器是指在生成一个标准的CSS后，进行一些列的优化的工具。如用于自动补充各浏览器前缀的autoprefixer；用于去除冗余css的CSSClean等。大都依赖于PostCSS这个工具。</p>
<h3 id="3、JavaScript"><a href="#3、JavaScript" class="headerlink" title="3、JavaScript"></a>3、JavaScript</h3><h4 id="3-1-理解"><a href="#3-1-理解" class="headerlink" title="3.1 理解"></a>3.1 理解</h4><p>这个没有一个明确的翻译，名字里有Java纯粹是为了蹭热度。广义上的JS由其语言核心+DOM+BOM组成。</p>
<ul>
<li>JavaScript有一个比较简单的出生，但有个比较折腾的成长。目前其标准属于EcmaScript（Flash使用的ActionScript也是这个标准下的产物），现在的版本是第7版，正式名是ES2017，前几天刚定稿，老浏览器都不支持，需要通过bable工具转换为第5版才能让绝大多数浏览器正常执行。</li>
<li>JS是弱类型语言，其基本数据类型有number/boolean/string/undefined/symbol/(null)、引用类型object，包括function和array。基本类型按值访问，引用类型按地址访问。基本数据类型用typeof区分，引用类型需要使用instanceof或其特殊的判断方法区分。</li>
<li>在ES5时代变量作用域仅限于函数内，ES6后通过let能指定块级作用于。var存在变量提升，是个bug隐患点。</li>
<li>ES5时代没有定义class，可以通过function+prototype的方式模拟一个类。JS的继承主要是通过原型链实现的：<code>instance.__proto__.....__proto__ === Class.prototype</code>。</li>
<li>DOM（文档对象模型）描述了处理网页内容的方法和接口。如document.getElementById。</li>
<li>BOM（浏览器对象模型）描述了与浏览器进行交互的方法和接口。如location.href。</li>
<li>通过XMLHttpRequest发送HTTP请求，可以通过指定异步的方式实现AJAX。异步请求存在同源限制。</li>
<li>ES6规范中明确了异步操作的推荐做法即Promise。<br>主要理解两点：异步与事件驱动。两者相互结合构成了现在的JS的运行逻辑。</li>
<li>TypeScript<br>微软推出谷歌力捧的JS超集，实现了强类型、类等诸多C++、Java功能，目前也需要通过编译才能执行，未有浏览器原生支持。</li>
</ul>
<h3 id="二、代码执行环境"><a href="#二、代码执行环境" class="headerlink" title="二、代码执行环境"></a>二、代码执行环境</h3><h3 id="1、浏览器"><a href="#1、浏览器" class="headerlink" title="1、浏览器"></a>1、浏览器</h3><ul>
<li>浏览器的历史不过多介绍，当前PC主流有Chrome和IE/Edge两个，其余的Firefox、safari都很小众。这三类都是独自研制开发。移动端上的主流几乎只有Safari和Chrome两种。</li>
<li>单独谈渲染引擎主流的有Webkit(Blink)、Trident、Gecko。单独谈JS引擎主要有V8、charkra等。</li>
</ul>
<h3 id="2、Node-js"><a href="#2、Node-js" class="headerlink" title="2、Node.js"></a>2、Node.js</h3><p>Node.js®是一个基于Chrome V8 引擎的 JavaScript 运行时。 Node.js 使用高效、轻量级的事件驱动、非阻塞 I/O 模型。Node.js 之生态系统是目前最大的开源包管理系统。</p>
<h3 id="三、代码执行流程"><a href="#三、代码执行流程" class="headerlink" title="三、代码执行流程"></a>三、代码执行流程</h3><h3 id="1、编译"><a href="#1、编译" class="headerlink" title="1、编译"></a>1、编译</h3><p>以现阶段的通常情况来看，我们采用超前的ES6、ES7来写JS，用Less写CSS，用React等来实现View，这些代码通过import/export引用和发布。然后通过webpack、fis等工具『编译』成能被浏览器执行的HTML/JS/CSS。</p>
<h3 id="2、部署："><a href="#2、部署：" class="headerlink" title="2、部署："></a>2、部署：</h3><p>其中HTML如果涉及到与后端数据的直接耦合，则被认为是『模板』，部署到相应的接入层逻辑指定的线上地址，而其他内容如.js/.css/.png/.svg等，则与服务端分离，部署在CDN上以提供更快的访问速度。这个过程主要的问题在于如何控制浏览器缓存（HTTP缓存）。</p>
<h3 id="3、访问："><a href="#3、访问：" class="headerlink" title="3、访问："></a>3、访问：</h3><p>从URL被请求到HTML被返回的逻辑就暂且略去，主要谈HTML返回后的过程。<br>这一部分以真实请求的Performance为例讲解吧。不赘述？？？？后续找几篇文章填补空白。</p>
<h3 id="4、JSBridge-链接跳转"><a href="#4、JSBridge-链接跳转" class="headerlink" title="4、JSBridge(链接跳转)"></a>4、JSBridge(链接跳转)</h3><ul>
<li>JS → Native：发特定规则的url，被native拦下来就好了。</li>
<li>Native → JS：Native可以在JSContext中注入代码，或者通过javascript:xxxx这种方式调用。</li>
</ul>
<h3 id="四、常见的问题与debug"><a href="#四、常见的问题与debug" class="headerlink" title="四、常见的问题与debug"></a>四、常见的问题与debug</h3><h3 id="1、如何获取与定位问题"><a href="#1、如何获取与定位问题" class="headerlink" title="1、如何获取与定位问题"></a>1、如何获取与定位问题</h3><ul>
<li>最好用的工具就是chrome的开发者工具了。<h3 id="2、为什么会白页"><a href="#2、为什么会白页" class="headerlink" title="2、为什么会白页"></a>2、为什么会白页</h3></li>
<li>一种是JS的BUG导致的，一般来说在相同文件内的JS会由于错误阻塞运行。也就是上文有错，下文直接挂。当渲染在下文时就容易出现这种问题。</li>
<li>另一种情况比较少见就是在load事件后调用document.write导致。</li>
</ul>
<h3 id="3、XSS与CSRF"><a href="#3、XSS与CSRF" class="headerlink" title="3、XSS与CSRF"></a>3、XSS与CSRF</h3><ul>
<li>XSS是老生常谈的话题了，主要是由于HTML语言的『保留字』（&lt; &gt; ‘ “ ）被直接使用导致，大部分能够通过HTML转义避免。<br>CSRF现在大都不常见了，基本通过加密token校验来避免。<h3 id="4、性能"><a href="#4、性能" class="headerlink" title="4、性能"></a>4、性能</h3></li>
<li>为何觉得卡，是因为人眼的构造决定的，实际上没有连续的动画，动画都是一帧一帧组成的。如果普通大众能接受60帧，那就意味着对HTML的相应操作要在1000/60m=16ms内执行完毕，才不会掉帧。</li>
<li>还是可以通过chrome的preformance工具来进行定位。</li>
</ul>
<h3 id="五、「框架」新时代"><a href="#五、「框架」新时代" class="headerlink" title="五、「框架」新时代"></a>五、「框架」新时代</h3><ul>
<li>jQurey、Bootstrap：这个时代的特点就是乱，文件瞎引用，样式瞎写，但干起活来就是快，维护体验很差。</li>
<li>backbone：开始有了一些思想，主要是类比了MVC，在前端也搞了全套的M-V-C，强调数据-模板（样式）-逻辑分离。</li>
<li>MVVM：再后来开始分化，一些人觉得C不足以表意，因为其实干来干去都是在操作M和V，不如就叫VM，所以是MVVM。另一些人觉得前端这么简单的事儿不要搞复杂留着V就足够了，也就出现了MVVM的代表Angular，和纯View层的代表React。</li>
<li>Vue.js:渐进式框架,Vue 从根本上采用最小成本、渐进增量的设计。Vue 的核心库只专注于视图层，并且很容易与其他第三方库或现有项目集成。</li>
</ul>
<h3 id="六、新技术"><a href="#六、新技术" class="headerlink" title="六、新技术"></a>六、新技术</h3><ul>
<li>PWA：（ Progressive Web Apps，渐进式网页应用）是由谷歌提出的新一代 Web 应用概念，旨在提供可靠、快速、类似 Native 应用的服务方案。</li>
<li>AMP：谷歌提倡的一些列『最佳实践』，通过实现这些最佳实践，大概率能让你的网站速度飙升。</li>
<li>reactNative、Weex：以虚拟DOM技术为核心，尝试将其用非Web技术渲染执行。</li>
<li>webSocket：在HTTP2出现以前，提供的一个基于TCP的socket应用接口，全双工、可二进制传输是其特点。</li>
<li>WebGL：基于canvas和OpenGL，使得web也能进行大型游戏和渲染场景的制作。</li>
<li>WASM：厉害了，所有能被JS实现的最终都会被JS实现。类似安卓的so。</li>
<li>微信小程序：个人理解是：对现有限制浏览器体验的内容删减，纯数据驱动以限制web能力，缓存模板甚至缓存运行时以提升性能，提供了一个本质还是浏览器的东西。</li>
<li>Electron： 打包一个浏览器，钉钉。</li>
</ul>
<h3 id="七、讨论"><a href="#七、讨论" class="headerlink" title="七、讨论"></a>七、讨论</h3><ul>
<li>对残障人士更友好的网页：这个话题里中国比较远，下一题。</li>
<li>HybridApp：这个题好，其实非核心功能和弱交互功能，完全可以交给web实现。而web主要性能受限的网络则可以通过Hybrid的方式预先集成到App内部，需要时就能立刻提供服务。类似PWA。</li>
<li>参考书籍与站点 ：<br>《JavaScript高级程序设计》、《深入理解ES6》、Google Developer Docs、Mozilla Web Docs</li>
<li>常用工具 ：caniuse 查兼容性的神器、tinypng 压缩图片好工具</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/程序开发/">程序开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Deadlock
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: undefined,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






  </div>
</body>
</html>